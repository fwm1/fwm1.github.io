<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BIO、NIO、AIO的区别</title>
    <url>/2021/05/25/BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><ul>
<li>同步：一个流程中的每隔方法必须依次执行，具体到IO操作就是，线程触发IO操作并等待IO完成，或者需要轮询查看IO操作是否完成。</li>
<li>异步：调用方法立即返回，不需要等待方法结束就可以继续执行其他任务，具体到IO操作就是，线程触发IO操作后立即返回，当IO操作完成时会得到内核<strong>通知</strong>触发回调。</li>
</ul>
<h5 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h5><ul>
<li>阻塞：单个线程内遇到同步等待后，一直在原地等待同步方法返回结果，具体到IO操作就是，当试图对FD或socket进行IO读写时，若当时没有内容可读或无法写入，线程就一直等待，知道有内容可读或可写。</li>
<li>非阻塞：单个线程内遇到同步等待后，不会原地等待，而是直接返回，具体到IO操作就是，当试图对DF或socket进行读写时，若当时没有内容可读或无法写入，读写函数立即返回，不会等待。</li>
</ul>
<p><strong>阻塞与非阻塞指的的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候，I/O 操作立即返回还是阻塞；同步异步指的是，当数据已经ready的时候，读写操作是同步读还是异步读。</strong></p>
<h5 id="常见IO模型对比"><a href="#常见IO模型对比" class="headerlink" title="常见IO模型对比"></a>常见IO模型对比</h5><p>所有的系统IO分为2个阶段：<strong>等待IO就绪</strong> 和 <strong>实际IO操作</strong>，举例来说，socket.read()分为等待网卡buffer有可读数据和buffer中的数据复制到用户空间。</p>
<ul>
<li><p>如果是BIO，等待网卡IO就绪和复制数据到用户空间这两个步骤都是阻塞的；</p>
</li>
<li><p>如果是NIO，等待网卡IO就绪是非阻塞的，若网卡buffer中无可读数据，则直接返回；但复制数据到用户空间这个过程仍然是阻塞的，因此是同步非阻塞模型。</p>
</li>
<li><p>如果是AIO，这两个过程都是非阻塞的。</p>
</li>
</ul>
<p>下图是几种常见的IO模型对比：</p>
<p><img src="https://i.loli.net/2021/05/27/8mfnS3iXq67xlsw.png" alt="image-20210527151101643"></p>
<h5 id="同步阻塞-BIO"><a href="#同步阻塞-BIO" class="headerlink" title="同步阻塞(BIO)"></a>同步阻塞(BIO)</h5><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><ul>
<li>连接数较小</li>
<li>连接数比较固定</li>
</ul>
<h6 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket client = socket;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (InputStream is = client.getInputStream();</span><br><span class="line">                     OutputStream os = client.getOutputStream();) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span> ((c = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        os.write(bytes, <span class="number">0</span>, c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    os.flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步非阻塞-NIO"><a href="#同步非阻塞-NIO" class="headerlink" title="同步非阻塞(NIO)"></a>同步非阻塞(NIO)</h5><h6 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h6><ul>
<li>ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer…</li>
<li>MappedByteBuffer(mmap)</li>
<li>HeapByteBuffer</li>
<li>DirectByteBuffer  通过FullGC回收内存</li>
</ul>
<h6 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h6><ul>
<li>FileChannel(文件)</li>
<li>DatagramChannel(UDP)</li>
<li>SocketChannel、ServerSocketChannel(TCP)</li>
</ul>
<h6 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h6><ul>
<li>selector.select() 是阻塞的，无论是通过操作系统的通知(epoll)还是不停地轮询(select，poll)</li>
<li>selector.wakeup()解除阻塞在select上的线程，立即返回</li>
</ul>
<h6 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h6><ul>
<li>连接数较多</li>
<li>短连接</li>
</ul>
<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><ul>
<li>NIO依赖操作系统各自实现，JAVA原生的NIO编程复杂，不宜用；</li>
<li>建议使用成熟的NIO框架入Netty，解决了NIO的很多陷阱，屏蔽了不同操作系统的差异。</li>
</ul>
<h6 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">       serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">       Selector selector = Selector.open();</span><br><span class="line">       serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           selector.select();</span><br><span class="line">           Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">           Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">           <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">               SelectionKey key = iterator.next();</span><br><span class="line">               <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                   ServerSocketChannel serverChannel = ((ServerSocketChannel) key.channel());</span><br><span class="line">                   SocketChannel clientChannel = serverChannel.accept();</span><br><span class="line">                   clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                   clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                   SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">                   ByteBuffer buffer = ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]);</span><br><span class="line">                   <span class="keyword">int</span> read = clientChannel.read(buffer);</span><br><span class="line">                   <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                       key.cancel();</span><br><span class="line">                       clientChannel.close();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       buffer.flip();</span><br><span class="line">                       clientChannel.write(buffer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           iterator.remove();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h6 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h6><ul>
<li>Channel：全双工通道</li>
<li>Buffer：数据缓冲区</li>
<li>Selector：多路复用器</li>
</ul>
<h5 id="异步非阻塞-AIO"><a href="#异步非阻塞-AIO" class="headerlink" title="异步非阻塞(AIO)"></a>异步非阻塞(AIO)</h5><h6 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h6><ul>
<li>连接数较多</li>
<li>长连接</li>
</ul>
<p><em>参考</em>：</p>
<p><a href="https://zhuanlan.zhihu.com/p/23488863">https://zhuanlan.zhihu.com/p/23488863</a></p>
<p><a href="https://developer.aliyun.com/article/726698">https://developer.aliyun.com/article/726698</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+TravisCI实现自动发布博客</title>
    <url>/2021/05/26/hexo-TravisCI%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>以下步骤假设你已经安装好了必要的环境比如nodejs，掌握了hexo基本命令和原理，并且已经初始化好了hexo，也安装好了自定义主题。</p>
<h5 id="Hexo原理"><a href="#Hexo原理" class="headerlink" title="Hexo原理"></a>Hexo原理</h5><p>Hexo简单来说能够把md渲染成html文件，然后把渲染后的结果发布到github Page上，我们只要关注博客内容即可。几个关键命令：</p>
<ul>
<li>hexo init(初始化hexo)</li>
<li>hexo generate(开始渲染)</li>
<li>hexo deploy(部署到github)</li>
<li>hexo server(本地部署)</li>
</ul>
<h5 id="Hexo-TravisCI原理"><a href="#Hexo-TravisCI原理" class="headerlink" title="Hexo+TravisCI原理"></a>Hexo+TravisCI原理</h5><ul>
<li>github Page使用的仓库名为username.github.io</li>
<li>hexo渲染后的结果必须放在<strong>master</strong>分支，里面是渲染后的html</li>
<li>新建一个<strong>hexo-source</strong>分支用来存放原始的文件，里面是渲染前的md文件</li>
<li>平时在hexo-source分支上编写md文档，push到hexo-source远程分支上会触发TravisCI进行构建，把构建后的结果发布到master分支，实现push即发布的效果。</li>
</ul>
<h5 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h5><h6 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h6><ol>
<li><p>在一个空白目录下执行 hexo init，初始化一个hexo目录</p>
</li>
<li><p>在此目录下执行git init，将hexo目录加入git管理</p>
</li>
<li><p>执行 git remote add origin <a href="https://github.com/username/username.github.io.git">https://github.com/username/username.github.io.git</a></p>
</li>
<li><p>执行 git checkout -b hexo-source，新建一个hexo-source分支</p>
</li>
<li><p>执行 git add .</p>
</li>
<li><p>执行 git commit -m “init”</p>
</li>
<li><p>执行 git push -u origin hexo-source</p>
</li>
<li><p>此时你仓库的远程分支会多出一个hexo-source分支，内容大致如下</p>
<img src="https://i.loli.net/2021/05/26/fAh6SFjsEI3LX9U.png" alt="image-20210526152959057" style="zoom:50%;" /></li>
</ol>
<h6 id="配置TravisCI"><a href="#配置TravisCI" class="headerlink" title="配置TravisCI"></a>配置TravisCI</h6><p>这部分配置网上很多，可以参考以下博客：</p>
<p><a href="https://segmentfault.com/a/1190000021987832">https://segmentfault.com/a/1190000021987832</a></p>
<p><a href="https://juejin.cn/post/6844903517853843470">https://juejin.cn/post/6844903517853843470</a></p>
<p>主要内容是配置github与TravisCI的token秘钥之类的，让TravisCI能够有权限访问我们的github仓库，不多赘述。主要是大家的.travis.yml各不相同，下面贴出我的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> </span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">14.17</span><span class="number">.0</span>  <span class="comment"># 使用 nodejs LTS v14.17.0</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo-source</span> <span class="comment"># 只监控 hexo-source 的 branch</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules 加快构建速度</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="comment">## 根据你所用的主题和自定义的不同，这里会有所不同</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="comment"># 在 CI 环境内安装 Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 在根目录安装站点需要的依赖</span></span><br><span class="line"><span class="attr">script:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span> <span class="comment"># 根据个人情况，这里会有所不同</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span> <span class="comment"># 构建完成后不清除</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># 你刚刚设置的 token</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span> <span class="comment"># 保存历史</span></span><br><span class="line">  <span class="comment">#fqdn: blog.ne0ng.page # 自定义域名，使用 username.github.io 可删除</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">hexo-source</span> <span class="comment"># hexo 源文件所在的 branch</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">public</span> </span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span> <span class="comment"># 存放生成站点文件的 branch，使用 username.github.io 必须是 master</span></span><br></pre></td></tr></table></figure>

<p>注意.travis.yml配置是写在hexo-source分支的， 写完后git push到远程分支，正常的话就会触发TravisCI构建了。</p>
<p>Tips：</p>
<ul>
<li>git push触发TravisCI构建前，TravisCi会发送一封确认邮件到github绑定的邮箱，不在邮件点确认的话也是不会触发构建的，有时候会很久都接受不到邮件，貌似是TravisCI的消息队列的问题，只能慢慢等了。</li>
</ul>
<img src="https://i.loli.net/2021/05/26/JdDbcA76zhuSV2G.png" alt="image-20210526154123366" style="zoom:50%;" />

<ul>
<li>构建会有延迟，可以在TravisCI中看构建过程</li>
</ul>
<img src="https://i.loli.net/2021/05/26/HxFGZKep3wyVIrJ.png" alt="image-20210526160021058" style="zoom:50%;" />

]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM配置GC参数</title>
    <url>/2021/06/07/JVM%E9%85%8D%E7%BD%AEGC%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h5 id="GC日志配置参考"><a href="#GC日志配置参考" class="headerlink" title="GC日志配置参考"></a>GC日志配置参考</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 必备</span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"># 打印对象年龄分布情况</span><br><span class="line">-XX:+PrintTenuringDistribution </span><br><span class="line"># 每次GC时，对比一下GC前后堆内存情况</span><br><span class="line">-XX:+PrintHeapAtGC </span><br><span class="line"># 打印STW时间,是GC最重要的指标</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">    </span><br><span class="line"># GC日志输出的文件路径，%t表示以时间戳命名文件，避免gc日志每次重启被覆盖</span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"># 开启日志文件分割</span><br><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line"># 最多分割几个文件，超过之后从头文件开始写</span><br><span class="line">-XX:NumberOfGCLogFiles=<span class="number">14</span></span><br><span class="line"># 每个文件上限大小，超过就触发分割</span><br><span class="line">-XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性算法</title>
    <url>/2021/05/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h2><h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><ul>
<li>Consistency(<strong>一致性</strong>)：数据更新保持一致，可分为强一致性和最终一致性</li>
<li>Availability(<strong>可用性</strong>)：较好的响应性能，能容忍的延迟</li>
<li>Partition tolerance(<strong>分区容错性</strong>)：部分分区故障时仍能够保证一致性和可用性。</li>
</ul>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><ul>
<li>Basically Available(<strong>基本可用</strong>)：损失部分可用性，比如响应时间变长或部分功能服务降级。</li>
<li>Soft state(<strong>软状态</strong>)：允许系统在不同节点的数据副本之间进行数据同步的过程存在延迟。</li>
<li>Eventually consistent(<strong>最终一致性</strong>)</li>
</ul>
<h4 id="2PC-两阶段提交"><a href="#2PC-两阶段提交" class="headerlink" title="2PC-两阶段提交"></a>2PC-两阶段提交</h4><hr>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ul>
<li>投票阶段<ol>
<li>协调者询问参与者是否可以执行</li>
<li>参与者执行事务并记录undo和redo日志</li>
<li>参与者回复协调者YES/NO</li>
</ol>
</li>
<li>提交阶段<ol>
<li>协调者根据收到的ACK发送提交请求或者回滚请求</li>
<li>参与者根据请求提交事务或回滚事务，并返回ACK</li>
<li>协调者根据ACK判断事务是否完成</li>
</ol>
</li>
</ul>
<p>Tips: Undo日志–事务回滚恢复时使用；Redo日志–服务器宕机时数据恢复</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>实现简单</li>
<li>强一致性</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>单点故障，协调者宕机后，参与者可能因为一直收不到命令而阻塞</li>
<li>同步阻塞等待，降低吞吐量</li>
<li>提交阶段若部分参与者没有doCommit，导致数据不一致</li>
</ul>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><hr>
<h6 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h6><ul>
<li>将2PC的第一阶段拆分为两个阶段，先发起事务询问，再执行事务。</li>
<li>协调者和参与者都引入超时机制，避免持续阻塞。</li>
</ul>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul>
<li>降低了2PC的同步阻塞范围。若doCommit阶段因为网络问题参与者没有收到协调者的doCommit请求，在超时过后参与者也会提交事务。</li>
<li>解决单点问题。doCommit阶段有可能会出现2中异常：1.协调者宕机；2.协调者与参与者网络故障。斗湖导致参与者无法收到doCommit请求，但在超时后都会自动提交事务。</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>有点同样是缺点，在doCommit阶段若参与者与协调者无法正常通信，超时后参与者都会提交事务，可能会导致数据不一致。</li>
</ul>
<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><ul>
<li>Chubby-Google的分布式锁</li>
<li>Zookeeper</li>
<li>Mysql5.7+ MySQL Group Replication</li>
</ul>
<p>完整的分布式一致性算法必须要考虑协调者宕机的情况，要能够投票选择出新的协调者并保持状态同步。因此严格意义上，2PC和3PC都只能是算未完全体的分布式一致性算法，因为协调者都要提前指定的，当协调者宕机后无法自动投票出新的协调者。</p>
<h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><hr>
<h6 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h6><p>有三种角色，每个节点可以同时属于多个角色。</p>
<ul>
<li>Proposers(提议者) ：提出提案。包括提案编号和提议的value</li>
<li>Acceptor(接受者)：参与决策，过半接受提案才被批准</li>
<li>Leaners(学习者)：不参与决策，只能学习被批准的提案</li>
</ul>
<h6 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h6><ul>
<li>Prepare阶段<ol>
<li>Proposer选择一个提案编号N，向半数以上的Acceptor发送编号N的Prepare请求</li>
<li>Acceptor收到一个编号为N的Prepare请求，比较自己已经响应过的最大的Prepare请求编号M，若N&gt;M，则接受提案，并把M放在Response中返回给Proposer，并承诺不再接受任何编号&lt;N的Prepare请求</li>
</ol>
</li>
<li>Accept阶段<ol>
<li>若Proposer收到半数以上Acceptor针对其编号N的Response，则发送一个针对**[N, V]**提案的Accept请求给Acceptor。V是上个阶段中Proposer收到的Response中最大编号值。</li>
<li>若Acceptor收到针对编号N的提案的Accept请求，比较自己已经响应过的最大的Prepare请求编号M，若N&gt;M，则接受此提案。</li>
</ol>
</li>
</ul>
<h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h4><hr>
<h6 id="节点角色-1"><a href="#节点角色-1" class="headerlink" title="节点角色"></a>节点角色</h6><p>有三种角色，每个节点同时只能属于一个角色，正常运行时只有Leader和Follower角色，选举过程中才会有Candidate角色。</p>
<ul>
<li>Leader：接受请求，向Follower同步日志，当日志同步到过半Follower上之后告诉Follower提交日志。</li>
<li>Follower：接受并持久化Leader同步过来的日志，发送到Follower的客户端请求会被转发到Leader。</li>
<li>Candidate：Leader选举过程中的临时角色，Follower在超时时间内(100~300ms)没有收到Leader的心跳，随机等待一段时间后发起一次选举。</li>
</ul>
<h6 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h6><ul>
<li>Leader选举阶段<ol>
<li>初始时所有节点都是Follower，一段时间后大家都没有收到Leader的心跳，则所有Follower节点都<strong>随机等待一段时间</strong>后发起一次选举；</li>
<li>Follower将其当前<strong>term+1</strong>，然后转换成Candidate角色，向其他Candidate发送投票请求；</li>
<li>若某个Follower收到多数选票，则升级成Leader；若收到Leader消息，说明有其他节点已经升级为Leader；若没有节点获得过半选票，Leader选举失败，超时后进行下一轮选举。</li>
</ol>
</li>
<li>日志同步(2PC)<ol>
<li>Leader收到客户端或其他Follower节点转发过来的需要同步的值，会跟随心跳一起广播给所有Follower节点；</li>
<li>Follower节点写入日志后，返回响应，当Leader收到过半的成功响应后，发送commit请求；</li>
<li>Follower节点收到commit请求后提交事务，返回响应；Leader收到过半commit成功后，同步结束。</li>
</ol>
</li>
</ul>
<img src="https://i.loli.net/2021/05/25/2RfsJKVXgLyEtqh.png" alt="image-20210525144955669"  />
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>2PC</tag>
        <tag>3PC</tag>
        <tag>Paxos</tag>
        <tag>Raft</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>disruptor探索</title>
    <url>/2021/10/30/disruptor%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="从Logger4j2引出Disruptor"><a href="#从Logger4j2引出Disruptor" class="headerlink" title="从Logger4j2引出Disruptor"></a>从Logger4j2引出Disruptor</h2><p>最近把日志框架从logback切换到了log4j2，号称在多线程环境下性能优于log4j和logback数十倍，下面是log4j2官网提供的经典峰值吞吐量对比图。Log4j 2的 Async Loggers 支持使用无锁数据结构（Disruptor），而 Logback、 Log4j 则只支持 ArrayBlockingQueue，多线程下无法避免锁争用，从而导致吞吐量大大降低。<br><img src="https://i.loli.net/2021/10/31/HzdbZD95w4CFip1.png" alt="image-20211031110132988"></p>
<h2 id="Disruptor是什么"><a href="#Disruptor是什么" class="headerlink" title="Disruptor是什么"></a>Disruptor是什么</h2><blockquote>
<p>Disruptor是一个高性能的无锁并发框架，提供了一种线程消息传递的方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID生成方法总结</title>
    <url>/2021/11/14/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="分布式ID应用场景"><a href="#分布式ID应用场景" class="headerlink" title="分布式ID应用场景"></a>分布式ID应用场景</h3><p>分库分表场景</p>
<h3 id="分布式ID特性"><a href="#分布式ID特性" class="headerlink" title="分布式ID特性"></a>分布式ID特性</h3><ul>
<li>全局唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>最好是有序递增</li>
</ul>
<h3 id="分布式ID实现方式"><a href="#分布式ID实现方式" class="headerlink" title="分布式ID实现方式"></a>分布式ID实现方式</h3><ul>
<li>UUID</li>
<li>数据库自增</li>
<li>号段模式</li>
<li>雪花算法</li>
<li>借助Redis</li>
</ul>
<h3 id="JDK的UUID"><a href="#JDK的UUID" class="headerlink" title="JDK的UUID"></a>JDK的UUID</h3><ul>
<li>优点：简单，性能，全球唯一性</li>
<li>缺点：字符串存储，可读性差，无序，数据库占用空间大且查询效率低</li>
</ul>
<h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3><p>使用数据库的主键不唯一特性保证唯一性。（使用MyISAM引擎是因为不会有update场景）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `SEQ_ID`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    id <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>单台数据库在高并发下很容易达到性能瓶颈且不能保证高可用，因此需要数据库<strong>双主模式集群</strong>，同时两个数据库设置主键的<strong>起始值</strong>和<strong>步长</strong></p>
<p>mysql1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p>mysql2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p>优点：唯一性保证，自增</p>
<p>缺点：mysql单点风险，集群模式扩容方案复杂，高并发能力有限</p>
<h3 id="基于数据库的号段模式（常用）"><a href="#基于数据库的号段模式（常用）" class="headerlink" title="基于数据库的号段模式（常用）"></a>基于数据库的号段模式（常用）</h3><ol>
<li>数据库自增ID模式下，每次获取ID都要访问一次数据库，造成数据库压力大</li>
<li>改为每次获取一个segment(step决定大小)号段的值，用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力</li>
<li> 各个业务不同的发号需求用biz_tag字段来区分，每个app-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对app-tag分库分表就行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `segments`</span><br><span class="line">(</span><br><span class="line">    `app_tag`     <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `max_id`      <span class="type">BIGINT</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `step`        <span class="type">BIGINT</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `update_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`app_tag`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> segments(`app_tag`, `max_id`, `step`) <span class="keyword">VALUES</span> (<span class="string">&#x27;test_business&#x27;</span>, <span class="number">0</span>, <span class="number">100000</span>);</span><br></pre></td></tr></table></figure>

<p>架构图如下</p>
<p><img src="https://i.loli.net/2021/11/14/uMlwINXBT6kJEHh.png" alt="image-20211114111047924"></p>
<p>test_tag在第一台Leaf机器上是1<del>1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001</del>4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line">UPDATE <span class="keyword">table</span> <span class="keyword">SET</span> max_id<span class="operator">=</span>max_id<span class="operator">+</span>step <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是<strong>趋势递增</strong>的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID号码<strong>不够随机</strong>，通过id号相减能获取大概的id生成数量，泄露id数量的信息，<strong>不太安全</strong>。</li>
<li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li>
<li><strong>DB宕机会造成整个系统不可用</strong>。</li>
</ul>
<h4 id="双buffer优化"><a href="#双buffer优化" class="headerlink" title="双buffer优化"></a>双buffer优化</h4><p>如果等到号段用完再去mysql拿新的号段，可能会阻塞业务线程，且业务响应容易受到数据库性能或网络影响。</p>
<p>为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。</p>
<p>采用<strong>双buffer</strong>的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p>
<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p><img src="https://i.loli.net/2021/11/14/GNXkFMyxvTOj4SW.png" alt="image-20211114114923848"></p>
<p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。Snowflake ID组成结构：<code>符号位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p>
<ul>
<li>符号位（1bit）Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0</li>
<li>时间戳（41bit）毫秒级的时间，不建议存当前时间戳，而是用<code>当前时间戳 - 固定开始时间戳</code>的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以</li>
<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成<strong>4096</strong>个ID</li>
</ul>
<h4 id="雪花算法Java实现"><a href="#雪花算法Java实现" class="headerlink" title="雪花算法Java实现"></a>雪花算法Java实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlakeShortUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_TIMESTAMP = <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>;   <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>;     <span class="comment">//机器标识占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">5</span>; <span class="comment">//数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATA_CENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> dataCenterId;  <span class="comment">//数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> machineId;     <span class="comment">//机器标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;  <span class="comment">//上一次时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mill = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastTimeStamp) &#123;</span><br><span class="line">            mill = getNewTimeStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterId 数据中心ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> machineId    机器标志ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlakeShortUrl</span><span class="params">(<span class="keyword">long</span> dataCenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;DtaCenterId can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;MachineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currTimeStamp = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currTimeStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimeStamp = currTimeStamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="comment">//时间戳部分</span></span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class="comment">//数据中心部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分</span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SnowFlakeShortUrl snowFlake = <span class="keyword">new</span> SnowFlakeShortUrl(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++) &#123;</span><br><span class="line">            <span class="comment">//10进制</span></span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="雪花算法时钟回拨问题"><a href="#雪花算法时钟回拨问题" class="headerlink" title="雪花算法时钟回拨问题"></a>雪花算法时钟回拨问题</h4><p>如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号。</p>
<ul>
<li><p>节点启动时，若zk节点存在，说明之前已经启动过。则用自身系统时间与<code>forever/$&#123;self&#125;</code>节点记录时间做比较，若小于<code>leaf_forever/$&#123;self&#125;</code>时间则认为机器时间发生了大步长回拨，服务启动失败</p>
</li>
<li><p>节点启动时，若zk节点不存在，说明是新增服务机器，直接创建<code>forever/$&#123;self&#125;</code>持久子节点，并写入当前机器系统时间；并且获取<code>temporary根节点</code>下所有子节点（其他服务机器的ipPort信息），通过rpc或http接口获取到其他所有机器的时间，计算出<code>时间戳平均值</code>。</p>
</li>
<li><p>如果<code>abs(时间戳平均值-当前机器系统时间) &lt; 阈值</code>，说明当前机器时间正常，启动服务并且写入到<code>temporary/$&#123;self&#125;</code>维持租约； 否则说明当前机器发生偏移，启动失败。</p>
</li>
<li><p>每隔一段时间(3s)上报自身系统时间写入<code>leaf_forever/$&#123;self&#125;</code></p>
</li>
</ul>
<p>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。<strong>或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发生了回拨，此刻时间小于上次发号时间</span></span><br><span class="line"> <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">long</span> offset = lastTimestamp - timestamp;</span><br><span class="line">            <span class="keyword">if</span> (offset &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">//时间偏差大小小于5ms，则等待两倍时间</span></span><br><span class="line">                    thread_wait(offset &lt;&lt; <span class="number">1</span>);<span class="comment">//wait</span></span><br><span class="line">                    timestamp = getTimeStamp();</span><br><span class="line">                    <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">                       <span class="comment">//还是小于，抛异常并上报</span></span><br><span class="line">                        throwClockBackwardsEx(timestamp);</span><br><span class="line">                      &#125;    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span>  e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//throw</span></span><br><span class="line">                throwClockBackwardsEx(timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//分配ID     </span></span><br></pre></td></tr></table></figure>

<p>优点：全局唯一，高可用， 利用zookeeper解决时钟回拨问题，弱依赖zookeeper</p>
<p>缺点：依赖第三方组件，架构较为复杂</p>
<h3 id="借助Redis"><a href="#借助Redis" class="headerlink" title="借助Redis"></a>借助Redis</h3><p>利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。需要考虑redis持久化的问题。</p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<p>优点：不依赖数据库，性能好</p>
<p>缺点：依赖第三方组件</p>
]]></content>
      <categories>
        <category>分布式ID</category>
      </categories>
      <tags>
        <tag>分布式ID</tag>
      </tags>
  </entry>
</search>
