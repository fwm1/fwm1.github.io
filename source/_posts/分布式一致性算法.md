---
title: 分布式一致性算法
date: 2021-05-25 10:05:10
tags: 分布式,2PC,3PC,Paxos,Raft,事务
categories: 分布式
---

## 分布式一致性协议

#### CAP理论

- Consistency(**一致性**)：数据更新保持一致，可分为强一致性和最终一致性
- Availability(**可用性**)：较好的响应性能，能容忍的延迟
- Partition tolerance(**分区容错性**)：部分分区故障时仍能够保证一致性和可用性。

#### BASE理论

- Basically Available(**基本可用**)：损失部分可用性，比如响应时间变长或部分功能服务降级。
- Soft state(**软状态**)：允许系统在不同节点的数据副本之间进行数据同步的过程存在延迟。
- Eventually consistent(**最终一致性**)

#### 2PC-两阶段提交

------

###### 实现

- 投票阶段
  1. 协调者询问参与者是否可以执行
  2. 参与者执行事务并记录undo和redo日志
  3. 参与者回复协调者YES/NO
- 提交阶段
  1. 协调者根据收到的ACK发送提交请求或者回滚请求
  2. 参与者根据请求提交事务或回滚事务，并返回ACK
  3. 协调者根据ACK判断事务是否完成

Tips: Undo日志--事务回滚恢复时使用；Redo日志--服务器宕机时数据恢复

###### 优点

- 实现简单
- 强一致性

###### 缺点

- 单点故障，协调者宕机后，参与者可能因为一直收不到命令而阻塞
- 同步阻塞等待，降低吞吐量
- 提交阶段若部分参与者没有doCommit，导致数据不一致

#### 3PC

------

###### 实现

- 将2PC的第一阶段拆分为两个阶段，先发起事务询问，再执行事务。
- 协调者和参与者都引入超时机制，避免持续阻塞。

###### 优点

- 降低了2PC的同步阻塞范围。若doCommit阶段因为网络问题参与者没有收到协调者的doCommit请求，在超时过后参与者也会提交事务。
- 解决单点问题。doCommit阶段有可能会出现2中异常：1.协调者宕机；2.协调者与参与者网络故障。斗湖导致参与者无法收到doCommit请求，但在超时后都会自动提交事务。

###### 缺点

- 有点同样是缺点，在doCommit阶段若参与者与协调者无法正常通信，超时后参与者都会提交事务，可能会导致数据不一致。

###### 应用

- Chubby-Google的分布式锁
- Zookeeper
- Mysql5.7+ MySQL Group Replication

完整的分布式一致性算法必须要考虑协调者宕机的情况，要能够投票选择出新的协调者并保持状态同步。因此严格意义上，2PC和3PC都只能是算未完全体的分布式一致性算法，因为协调者都要提前指定的，当协调者宕机后无法自动投票出新的协调者。

#### Paxos算法

------

###### 节点角色

有三种角色，每个节点可以同时属于多个角色。

- Proposers(提议者) ：提出提案。包括提案编号和提议的value
- Acceptor(接受者)：参与决策，过半接受提案才被批准
- Leaners(学习者)：不参与决策，只能学习被批准的提案

###### 实现

- Prepare阶段
  1. Proposer选择一个提案编号N，向半数以上的Acceptor发送编号N的Prepare请求
  2. Acceptor收到一个编号为N的Prepare请求，比较自己已经响应过的最大的Prepare请求编号M，若N>M，则接受提案，并把M放在Response中返回给Proposer，并承诺不再接受任何编号<N的Prepare请求
- Accept阶段
  1. 若Proposer收到半数以上Acceptor针对其编号N的Response，则发送一个针对**[N, V]**提案的Accept请求给Acceptor。V是上个阶段中Proposer收到的Response中最大编号值。
  2. 若Acceptor收到针对编号N的提案的Accept请求，比较自己已经响应过的最大的Prepare请求编号M，若N>M，则接受此提案。

#### Raft算法

------

###### 节点角色

有三种角色，每个节点同时只能属于一个角色，正常运行时只有Leader和Follower角色，选举过程中才会有Candidate角色。

- Leader：接受请求，向Follower同步日志，当日志同步到过半Follower上之后告诉Follower提交日志。
- Follower：接受并持久化Leader同步过来的日志，发送到Follower的客户端请求会被转发到Leader。
- Candidate：Leader选举过程中的临时角色，Follower在超时时间内(100~300ms)没有收到Leader的心跳，随机等待一段时间后发起一次选举。

###### 实现

- Leader选举阶段
  1. 初始时所有节点都是Follower，一段时间后大家都没有收到Leader的心跳，则所有Follower节点都**随机等待一段时间**后发起一次选举；
  2. Follower将其当前**term+1**，然后转换成Candidate角色，向其他Candidate发送投票请求；
  3. 若某个Follower收到多数选票，则升级成Leader；若收到Leader消息，说明有其他节点已经升级为Leader；若没有节点获得过半选票，Leader选举失败，超时后进行下一轮选举。
- 日志同步(2PC)
  1. Leader收到客户端或其他Follower节点转发过来的需要同步的值，会跟随心跳一起广播给所有Follower节点；
  2. Follower节点写入日志后，返回响应，当Leader收到过半的成功响应后，发送commit请求；
  3. Follower节点收到commit请求后提交事务，返回响应；Leader收到过半commit成功后，同步结束。

<img src="https://i.loli.net/2021/05/25/2RfsJKVXgLyEtqh.png" alt="image-20210525144955669"  />
