<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BIO、NIO、AIO的区别</title>
    <url>/2021/05/25/BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><ul>
<li>同步：一个流程中的每隔方法必须依次执行，具体到IO操作就是，线程触发IO操作并等待IO完成，或者需要轮询查看IO操作是否完成。</li>
<li>异步：调用方法立即返回，不需要等待方法结束就可以继续执行其他任务，具体到IO操作就是，线程触发IO操作后立即返回，当IO操作完成时会得到内核<strong>通知</strong>触发回调。</li>
</ul>
<h5 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h5><ul>
<li>阻塞：单个线程内遇到同步等待后，一直在原地等待同步方法返回结果，具体到IO操作就是，当试图对FD或socket进行IO读写时，若当时没有内容可读或无法写入，线程就一直等待，知道有内容可读或可写。</li>
<li>非阻塞：单个线程内遇到同步等待后，不会原地等待，而是直接返回，具体到IO操作就是，当试图对DF或socket进行读写时，若当时没有内容可读或无法写入，读写函数立即返回，不会等待。</li>
</ul>
<p><strong>阻塞与非阻塞指的的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候，I/O 操作立即返回还是阻塞；同步异步指的是，当数据已经ready的时候，读写操作是同步读还是异步读。</strong></p>
<h5 id="常见IO模型对比"><a href="#常见IO模型对比" class="headerlink" title="常见IO模型对比"></a>常见IO模型对比</h5><p>所有的系统IO分为2个阶段：<strong>等待IO就绪</strong> 和 <strong>实际IO操作</strong>，举例来说，socket.read()分为等待网卡buffer有可读数据和buffer中的数据复制到用户空间。</p>
<ul>
<li><p>如果是BIO，等待网卡IO就绪和复制数据到用户空间这两个步骤都是阻塞的；</p>
</li>
<li><p>如果是NIO，等待网卡IO就绪是非阻塞的，若网卡buffer中无可读数据，则直接返回；但复制数据到用户空间这个过程仍然是阻塞的，因此是同步非阻塞模型。</p>
</li>
<li><p>如果是AIO，这两个过程都是非阻塞的。</p>
</li>
</ul>
<p>下图是几种常见的IO模型对比：</p>
<p><img src="https://i.loli.net/2021/05/27/8mfnS3iXq67xlsw.png" alt="image-20210527151101643"></p>
<h5 id="同步阻塞-BIO"><a href="#同步阻塞-BIO" class="headerlink" title="同步阻塞(BIO)"></a>同步阻塞(BIO)</h5><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><ul>
<li>连接数较小</li>
<li>连接数比较固定</li>
</ul>
<h6 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket client = socket;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (InputStream is = client.getInputStream();</span><br><span class="line">                     OutputStream os = client.getOutputStream();) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span> ((c = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        os.write(bytes, <span class="number">0</span>, c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    os.flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步非阻塞-NIO"><a href="#同步非阻塞-NIO" class="headerlink" title="同步非阻塞(NIO)"></a>同步非阻塞(NIO)</h5><h6 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h6><ul>
<li>ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer…</li>
<li>MappedByteBuffer(mmap)</li>
<li>HeapByteBuffer</li>
<li>DirectByteBuffer  通过FullGC回收内存</li>
</ul>
<h6 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h6><ul>
<li>FileChannel(文件)</li>
<li>DatagramChannel(UDP)</li>
<li>SocketChannel、ServerSocketChannel(TCP)</li>
</ul>
<h6 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h6><ul>
<li>selector.select() 是阻塞的，无论是通过操作系统的通知(epoll)还是不停地轮询(select，poll)</li>
<li>selector.wakeup()解除阻塞在select上的线程，立即返回</li>
</ul>
<h6 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h6><ul>
<li>连接数较多</li>
<li>短连接</li>
</ul>
<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><ul>
<li>NIO依赖操作系统各自实现，JAVA原生的NIO编程复杂，不宜用；</li>
<li>建议使用成熟的NIO框架入Netty，解决了NIO的很多陷阱，屏蔽了不同操作系统的差异。</li>
</ul>
<h6 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">       serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">       Selector selector = Selector.open();</span><br><span class="line">       serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           selector.select();</span><br><span class="line">           Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">           Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">           <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">               SelectionKey key = iterator.next();</span><br><span class="line">               <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                   ServerSocketChannel serverChannel = ((ServerSocketChannel) key.channel());</span><br><span class="line">                   SocketChannel clientChannel = serverChannel.accept();</span><br><span class="line">                   clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                   clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                   SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">                   ByteBuffer buffer = ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]);</span><br><span class="line">                   <span class="keyword">int</span> read = clientChannel.read(buffer);</span><br><span class="line">                   <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                       key.cancel();</span><br><span class="line">                       clientChannel.close();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       buffer.flip();</span><br><span class="line">                       clientChannel.write(buffer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           iterator.remove();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h6 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h6><ul>
<li>Channel：全双工通道</li>
<li>Buffer：数据缓冲区</li>
<li>Selector：多路复用器</li>
</ul>
<h5 id="异步非阻塞-AIO"><a href="#异步非阻塞-AIO" class="headerlink" title="异步非阻塞(AIO)"></a>异步非阻塞(AIO)</h5><h6 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h6><ul>
<li>连接数较多</li>
<li>长连接</li>
</ul>
<p><em>参考</em>：</p>
<p><a href="https://zhuanlan.zhihu.com/p/23488863">https://zhuanlan.zhihu.com/p/23488863</a></p>
<p><a href="https://developer.aliyun.com/article/726698">https://developer.aliyun.com/article/726698</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM配置GC参数</title>
    <url>/2021/06/07/JVM%E9%85%8D%E7%BD%AEGC%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h5 id="GC日志配置参考"><a href="#GC日志配置参考" class="headerlink" title="GC日志配置参考"></a>GC日志配置参考</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 必备</span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"># 打印对象年龄分布情况</span><br><span class="line">-XX:+PrintTenuringDistribution </span><br><span class="line"># 每次GC时，对比一下GC前后堆内存情况</span><br><span class="line">-XX:+PrintHeapAtGC </span><br><span class="line"># 打印STW时间,是GC最重要的指标</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">    </span><br><span class="line"># GC日志输出的文件路径，%t表示以时间戳命名文件，避免gc日志每次重启被覆盖</span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"># 开启日志文件分割</span><br><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line"># 最多分割几个文件，超过之后从头文件开始写</span><br><span class="line">-XX:NumberOfGCLogFiles=<span class="number">14</span></span><br><span class="line"># 每个文件上限大小，超过就触发分割</span><br><span class="line">-XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java细粒度锁</title>
    <url>/2022/03/24/Java%E5%A4%9A%E7%B2%92%E5%BA%A6%E9%94%81/</url>
    <content><![CDATA[<h3 id="从WeakHashMap实现分段锁"><a href="#从WeakHashMap实现分段锁" class="headerlink" title="从WeakHashMap实现分段锁"></a>从WeakHashMap实现分段锁</h3><p>当弱引用指向的对象引用被释放之后 Java 会在下一次的 GC 将这弱引用指向的对象回收掉，在经过 GC 之后，当弱引用指向的对象被回收时，弱引用将会进入创建时指定的队列。</p>
<p>WeakHashMap使用<strong>弱引用</strong>作为 key，通过轮询referenceQueue清理被gc的弱引用对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">                Entry&lt;K,V&gt; p = prev;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (prev == e)</span><br><span class="line">                            table[i] = next;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            prev.next = next;</span><br><span class="line">                        <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                        <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                        size--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>为什么不能直接用WeakHashMap实现细粒度锁：线程不安全。</p>
<p>替代方案：</p>
<ol>
<li>Collections.synchronizedMap 性能差</li>
<li>ConcurrentReferenceHashMap</li>
</ol>
<h3 id="ConcurrentReferenceHashMap实现细粒度锁"><a href="#ConcurrentReferenceHashMap实现细粒度锁" class="headerlink" title="ConcurrentReferenceHashMap实现细粒度锁"></a>ConcurrentReferenceHashMap实现细粒度锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentReferenceHashMap&lt;T, ReentrantLock&gt; referenceHashMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakHashLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenceHashMap = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(</span><br><span class="line">                <span class="number">16</span>, <span class="number">0.75f</span>, <span class="number">16</span>, ConcurrentReferenceHashMap.ReferenceType.WEAK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReentrantLock <span class="title">get</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.referenceHashMap.computeIfAbsent(key, lock -&gt; <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Guava-Striped实现细粒度锁"><a href="#Guava-Striped实现细粒度锁" class="headerlink" title="Guava Striped实现细粒度锁"></a>Guava Striped实现细粒度锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Striped&lt;Lock&gt; lockStriped = Striped.lazyWeakLock(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>Striped能保证hashcode相等的对象拿到的是同一个锁，但是<strong>hashcode不同的对象也可能拿到同一把锁</strong>，由trip个数决定并发度。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis核心机制</title>
    <url>/2022/03/24/Redis%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>作用：数据冗余、故障恢复、负载均衡、高可用</p>
<p>复制方式：全量复制和增量复制</p>
<h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><ol>
<li><p>主从库间建立连接、协商同步</p>
<p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了<strong>主库的 runID</strong> 和复<strong>制进度 offset</strong> 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</p>
</li>
<li><p>主库将所有数据同步给从库</p>
<p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 <strong>replication buffer</strong>，记录 RDB 文件生成后收到的所有写操作。</p>
</li>
<li><p>主库会把第二阶段执行过程中新收到的写命令，再发送给从库</p>
<p>从库接受到新的写命令后，再重新执行这些操作。</p>
</li>
</ol>
<h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>作用：主节点的自动故障转移</p>
<p>Redis Sentinel本身也是一个集群，可以：</p>
<ol>
<li>对于redis数据节点的连通信由多个sentinel节点共同决定（主观、客观下线），避免误判；</li>
<li>sentinel本身的高可用</li>
</ol>
<p>哨兵实现的功能：</p>
<ol>
<li>监控：其他sentinel节点  以及  redis主从节点</li>
<li>通知：通知上层应用</li>
<li><strong>自动故障转移</strong></li>
<li>客户端的配置中心，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息</li>
</ol>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>sentinel节点监控其他sentinel节点  以及  redis主从节点，是通过pub/sub功能实现的。</p>
<p>sentinel节点有3个定时任务：</p>
<ol>
<li>节点状态监控。每1秒向其他sentinel节点和redis主从节点发送<strong>PING</strong>命令，检测连通信</li>
<li>sentinel节点信息交换。每2秒向redis主节点的”____sentinel____hello”的channel发送自身信息以及对自己认为的主节点信息。</li>
<li>监控主从拓扑结构信息。每10s，每个sentinel节点会向主从节点发送<strong>INFO</strong>命令，获取主从信息。</li>
</ol>
<h4 id="主观-客观下线"><a href="#主观-客观下线" class="headerlink" title="主观/客观下线"></a>主观/客观下线</h4><p>主观下线：每个Sentinel节点，每隔1秒会对数据节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复时，Sentinel节点会对该节点做失败判定，这个行为叫做主观下线。</p>
<p>客观下线：是指当大多数Sentinel节点，都认为master节点宕机了，那么这个判定就是客观的，叫做客观下线。</p>
<h4 id="Sentinel-Leader选举（Raft）"><a href="#Sentinel-Leader选举（Raft）" class="headerlink" title="Sentinel Leader选举（Raft）"></a>Sentinel Leader选举（Raft）</h4><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>选举出的Leader Sentinel节点将负责故障转移。</p>
<ol>
<li>从slave节点中筛选出一个作为新的master，判断条件有以下几点：<ol>
<li>跟主节点断开时时长。如果一个slave跟master的断开连接时长已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么该slave就被认为不适合选举为master。</li>
<li>slave的优先级配置：slave priority参数值越小，优先级就越高。</li>
<li>复制offset：当优先级相同时，哪个slave复制了越多的数据（offset越靠后），优先级越高。</li>
<li>run id：如果offset和优先级都相同，则哪个slave的run id越小，优先级越高。</li>
</ol>
</li>
<li>对最终筛选出来的slave节点执行<strong>slaveof no one</strong>命令，使其成为主节点。</li>
<li>Leader Sentinel向剩余的slave节点发送命令，让它们成为新的master节点的从节点。</li>
<li>Leader Sentinel会将原来的主节点更新为从节点，并当其恢复后命令它去复制新的主节点。</li>
</ol>
<h3 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>查询不存在的key导致请求每次都查db</p>
<p>解决方案：</p>
<ol>
<li>应用层增加校验，非法查询提前过滤；</li>
<li>不存在的key缓存空值到redis，并设置合理的过期时间；</li>
<li>布隆过滤器；</li>
</ol>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>某个key缓存过期，此时大量并发查询请求打到db</p>
<p>解决办法：</p>
<ol>
<li>热点数据不设置过期时间；</li>
<li>接口做好限流、熔断机制；</li>
<li>查db时加集群锁+双检锁机制，同时只能由一个线程查db；</li>
</ol>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>大量key同时过期，导致大量查询请求打到db</p>
<p>解决办法：</p>
<ol>
<li>key设置随机过期时间，避免同时过期；</li>
<li>热点数据不设置过期时间；</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+TravisCI实现自动发布博客</title>
    <url>/2021/05/26/hexo-TravisCI%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>以下步骤假设你已经安装好了必要的环境比如nodejs，掌握了hexo基本命令和原理，并且已经初始化好了hexo，也安装好了自定义主题。</p>
<h5 id="Hexo原理"><a href="#Hexo原理" class="headerlink" title="Hexo原理"></a>Hexo原理</h5><p>Hexo简单来说能够把md渲染成html文件，然后把渲染后的结果发布到github Page上，我们只要关注博客内容即可。几个关键命令：</p>
<ul>
<li>hexo init(初始化hexo)</li>
<li>hexo generate(开始渲染)</li>
<li>hexo deploy(部署到github)</li>
<li>hexo server(本地部署)</li>
</ul>
<h5 id="Hexo-TravisCI原理"><a href="#Hexo-TravisCI原理" class="headerlink" title="Hexo+TravisCI原理"></a>Hexo+TravisCI原理</h5><ul>
<li>github Page使用的仓库名为username.github.io</li>
<li>hexo渲染后的结果必须放在<strong>master</strong>分支，里面是渲染后的html</li>
<li>新建一个<strong>hexo-source</strong>分支用来存放原始的文件，里面是渲染前的md文件</li>
<li>平时在hexo-source分支上编写md文档，push到hexo-source远程分支上会触发TravisCI进行构建，把构建后的结果发布到master分支，实现push即发布的效果。</li>
</ul>
<h5 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h5><h6 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h6><ol>
<li><p>在一个空白目录下执行 hexo init，初始化一个hexo目录</p>
</li>
<li><p>在此目录下执行git init，将hexo目录加入git管理</p>
</li>
<li><p>执行 git remote add origin <a href="https://github.com/username/username.github.io.git">https://github.com/username/username.github.io.git</a></p>
</li>
<li><p>执行 git checkout -b hexo-source，新建一个hexo-source分支</p>
</li>
<li><p>执行 git add .</p>
</li>
<li><p>执行 git commit -m “init”</p>
</li>
<li><p>执行 git push -u origin hexo-source</p>
</li>
<li><p>此时你仓库的远程分支会多出一个hexo-source分支，内容大致如下</p>
<img src="https://i.loli.net/2021/05/26/fAh6SFjsEI3LX9U.png" alt="image-20210526152959057" style="zoom:50%;" /></li>
</ol>
<h6 id="配置TravisCI"><a href="#配置TravisCI" class="headerlink" title="配置TravisCI"></a>配置TravisCI</h6><p>这部分配置网上很多，可以参考以下博客：</p>
<p><a href="https://segmentfault.com/a/1190000021987832">https://segmentfault.com/a/1190000021987832</a></p>
<p><a href="https://juejin.cn/post/6844903517853843470">https://juejin.cn/post/6844903517853843470</a></p>
<p>主要内容是配置github与TravisCI的token秘钥之类的，让TravisCI能够有权限访问我们的github仓库，不多赘述。主要是大家的.travis.yml各不相同，下面贴出我的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> </span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">14.17</span><span class="number">.0</span>  <span class="comment"># 使用 nodejs LTS v14.17.0</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo-source</span> <span class="comment"># 只监控 hexo-source 的 branch</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules 加快构建速度</span></span><br><span class="line"><span class="attr">before_script:</span> <span class="comment">## 根据你所用的主题和自定义的不同，这里会有所不同</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="comment"># 在 CI 环境内安装 Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 在根目录安装站点需要的依赖</span></span><br><span class="line"><span class="attr">script:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span> <span class="comment"># 根据个人情况，这里会有所不同</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span> <span class="comment"># 构建完成后不清除</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># 你刚刚设置的 token</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span> <span class="comment"># 保存历史</span></span><br><span class="line">  <span class="comment">#fqdn: blog.ne0ng.page # 自定义域名，使用 username.github.io 可删除</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">hexo-source</span> <span class="comment"># hexo 源文件所在的 branch</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">public</span> </span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span> <span class="comment"># 存放生成站点文件的 branch，使用 username.github.io 必须是 master</span></span><br></pre></td></tr></table></figure>

<p>注意.travis.yml配置是写在hexo-source分支的， 写完后git push到远程分支，正常的话就会触发TravisCI构建了。</p>
<p>Tips：</p>
<ul>
<li>git push触发TravisCI构建前，TravisCi会发送一封确认邮件到github绑定的邮箱，不在邮件点确认的话也是不会触发构建的，有时候会很久都接受不到邮件，貌似是TravisCI的消息队列的问题，只能慢慢等了。</li>
</ul>
<img src="https://i.loli.net/2021/05/26/JdDbcA76zhuSV2G.png" alt="image-20210526154123366" style="zoom:50%;" />

<ul>
<li>构建会有延迟，可以在TravisCI中看构建过程</li>
</ul>
<img src="https://i.loli.net/2021/05/26/HxFGZKep3wyVIrJ.png" alt="image-20210526160021058" style="zoom:50%;" />

]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性算法</title>
    <url>/2021/05/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h2><h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><ul>
<li>Consistency(<strong>一致性</strong>)：数据更新保持一致，可分为强一致性和最终一致性</li>
<li>Availability(<strong>可用性</strong>)：较好的响应性能，能容忍的延迟</li>
<li>Partition tolerance(<strong>分区容错性</strong>)：部分分区故障时仍能够保证一致性和可用性。</li>
</ul>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><ul>
<li>Basically Available(<strong>基本可用</strong>)：损失部分可用性，比如响应时间变长或部分功能服务降级。</li>
<li>Soft state(<strong>软状态</strong>)：允许系统在不同节点的数据副本之间进行数据同步的过程存在延迟。</li>
<li>Eventually consistent(<strong>最终一致性</strong>)</li>
</ul>
<h4 id="2PC-两阶段提交"><a href="#2PC-两阶段提交" class="headerlink" title="2PC-两阶段提交"></a>2PC-两阶段提交</h4><hr>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ul>
<li>投票阶段<ol>
<li>协调者询问参与者是否可以执行</li>
<li>参与者执行事务并记录undo和redo日志</li>
<li>参与者回复协调者YES/NO</li>
</ol>
</li>
<li>提交阶段<ol>
<li>协调者根据收到的ACK发送提交请求或者回滚请求</li>
<li>参与者根据请求提交事务或回滚事务，并返回ACK</li>
<li>协调者根据ACK判断事务是否完成</li>
</ol>
</li>
</ul>
<p>Tips: Undo日志–事务回滚恢复时使用；Redo日志–服务器宕机时数据恢复</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>实现简单</li>
<li>强一致性</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>单点故障，协调者宕机后，参与者可能因为一直收不到命令而阻塞</li>
<li>同步阻塞等待，降低吞吐量</li>
<li>提交阶段若部分参与者没有doCommit，导致数据不一致</li>
</ul>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><hr>
<p><img src="https://raw.githubusercontent.com/fwm1/PicturesRepo/master/blog-images/1517793175448046668.png" alt="1517793175448046668"></p>
<h6 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h6><ul>
<li>将2PC的第一阶段拆分为两个阶段（canCommit、preCommit），先发起事务询问，再执行事务（doCommit）。</li>
<li>协调者和参与者都引入超时机制，避免持续阻塞。</li>
</ul>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul>
<li>降低了2PC的同步阻塞范围。若doCommit阶段因为网络问题参与者没有收到协调者的doCommit请求，在超时过后参与者也会提交事务。</li>
<li>解决单点问题。doCommit阶段有可能会出现2中异常：1.协调者宕机；2.协调者与参与者网络故障。都会导致参与者无法收到doCommit请求，但在超时后都会自动提交事务。</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>优点同样是缺点，在doCommit阶段若参与者与协调者无法正常通信，超时后参与者都会提交事务，可能会导致数据不一致。</li>
</ul>
<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><ul>
<li>Chubby-Google的分布式锁</li>
<li>Zookeeper</li>
<li>Mysql5.7+ MySQL Group Replication</li>
</ul>
<p>完整的分布式一致性算法必须要考虑协调者宕机的情况，要能够投票选择出新的协调者并保持状态同步。因此严格意义上，2PC和3PC都只能是算未完全体的分布式一致性算法，因为协调者都要提前指定的，当协调者宕机后无法自动投票出新的协调者。</p>
<h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><hr>
<h6 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h6><p>有三种角色，每个节点可以同时属于多个角色。</p>
<ul>
<li>Proposers(提议者) ：提出提案。包括提案编号和提议的value</li>
<li>Acceptor(接受者)：参与决策，过半接受提案才被批准</li>
<li>Leaners(学习者)：不参与决策，只能学习被批准的提案</li>
</ul>
<h6 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h6><ul>
<li>Prepare阶段<ol>
<li>Proposer选择一个提案编号N，向半数以上的Acceptor发送编号N的Prepare请求</li>
<li>Acceptor收到一个编号为N的Prepare请求，比较自己已经响应过的最大的Prepare请求编号M，若N&gt;M，则接受提案，并把M放在Response中返回给Proposer，并承诺不再接受任何编号&lt;N的Prepare请求</li>
</ol>
</li>
<li>Accept阶段<ol>
<li>若Proposer收到半数以上Acceptor针对其编号N的Response，则发送一个针对**[N, V]**提案的Accept请求给Acceptor。V是上个阶段中Proposer收到的Response中最大编号值。</li>
<li>若Acceptor收到针对编号N的提案的Accept请求，比较自己已经响应过的最大的Prepare请求编号M，若N&gt;M，则接受此提案。</li>
</ol>
</li>
</ul>
<h4 id="Raft算法（强一致性）"><a href="#Raft算法（强一致性）" class="headerlink" title="Raft算法（强一致性）"></a>Raft算法（强一致性）</h4><hr>
<h6 id="节点角色-1"><a href="#节点角色-1" class="headerlink" title="节点角色"></a>节点角色</h6><p>有三种角色，每个节点同时只能属于一个角色，正常运行时只有Leader和Follower角色，选举过程中才会有Candidate角色。</p>
<ul>
<li>Leader：接受请求，向Follower同步日志，当日志同步到过半Follower上之后告诉Follower提交日志。</li>
<li>Follower：接受并持久化Leader同步过来的日志，发送到Follower的客户端请求会被转发到Leader。</li>
<li>Candidate：Leader选举过程中的临时角色，Follower在超时时间内(150~300ms)没有收到Leader的心跳，随机等待一段时间后发起一次选举。</li>
</ul>
<h6 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h6><ul>
<li>Leader选举阶段<ol>
<li>初始时所有节点都是Follower，一段时间后大家都没有收到Leader的心跳，则所有Follower节点都<strong>随机等待一段时间</strong>（150~300ms）后发起一次选举，随机时间是为了保证总有一个节点先发出拉票请求，避免选票被各自瓜分，导致选不出leader节点；</li>
<li>Follower将其当前<strong>term+1</strong>，然后转换成Candidate角色，向其他Follower发送投票请求；投票请求中包含1)<strong>此次选举的term</strong>和2)<strong>本Candidate的最新日志进度</strong>，如果Follower的日志offset比Candidate的日志还要新，就不会给Candidate投票。这是为了保证<em>Leader节点中的日志必须比大多数节点的要新</em>；</li>
<li>若某个Candidate收到多数选票，则升级成Leader；若收到Leader消息，说明有其他节点已经升级为Leader；若没有节点获得过半选票，Leader选举失败，超时后进行下一轮选举。</li>
</ol>
</li>
<li>日志同步(2PC)<ol>
<li>Leader收到客户端或其他Follower节点转发过来的需要同步的值，会跟随心跳一起广播给所有Follower节点；</li>
<li>Follower节点写入日志后，返回响应，当Leader收到过半的成功响应后，发送commit请求；</li>
<li>Follower节点收到commit请求后提交事务，返回响应；Leader收到过半commit成功后，同步结束。</li>
</ol>
</li>
</ul>
<img src="https://i.loli.net/2021/05/25/2RfsJKVXgLyEtqh.png" alt="image-20210525144955669"  />
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>2PC</tag>
        <tag>3PC</tag>
        <tag>Paxos</tag>
        <tag>Raft</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="分布式事务的典型场景"><a href="#分布式事务的典型场景" class="headerlink" title="分布式事务的典型场景"></a>分布式事务的典型场景</h3><ul>
<li>跨库事务</li>
<li>分库分表</li>
<li>跨服务调用场景下的分布式事务</li>
</ul>
<h3 id="X-Open-DTP模型"><a href="#X-Open-DTP模型" class="headerlink" title="X/Open DTP模型"></a>X/Open DTP模型</h3><p>X/Open是一个国际的技术标准组织，提出了DTP（Distributed Transaction Processing）模型。DTP模型包含以下5中基本元素：</p>
<ul>
<li>应用程序(Application Program ，AP)</li>
<li>资源管理器(Resource Manager，RM)，如数据库、文件系统</li>
<li>事务管理器(Resource Manager，TM)，负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚</li>
<li>通信资源管理器(Communication Resource Manager，CRM)</li>
<li>通信协议(Communication Protocol，CP)</li>
</ul>
<h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>XA规范的最主要的作用是，就是<strong>定义了RM-TM的交互接口</strong>，此外XA规范里也对二阶段提交的细节进行了优化和补充。</p>
<p><img src="https://gitee.com/fwm123/pictures-repo/raw/master/blog-images/20220512001007.png" alt="1578CD5A-2EE1-4F41-8DE8-B2F615F79571.png"></p>
<p><em>注：DTP模型中规定了全局事务的提交要使用二阶段提交，而XA规范中定义了二阶段提交的标准接口</em></p>
<h4 id="XA规范RM、TM标准交互接口"><a href="#XA规范RM、TM标准交互接口" class="headerlink" title="XA规范RM、TM标准交互接口"></a>XA规范RM、TM标准交互接口</h4><p><img src="https://gitee.com/fwm123/pictures-repo/raw/master/blog-images/20220512110823.png" alt="img"></p>
<h4 id="二阶段提交的缺陷"><a href="#二阶段提交的缺陷" class="headerlink" title="二阶段提交的缺陷"></a>二阶段提交的缺陷</h4><ul>
<li>同步阻塞</li>
<li>TM单点故障，TM发生故障，RM会一直阻塞等待，无法完成事务</li>
<li>数据不一致，在提交阶段，部分机器执行了commit，另外一部分机器因为网络没有收到commit命令，导致数据不一致</li>
</ul>
<h4 id="三阶段提交改进"><a href="#三阶段提交改进" class="headerlink" title="三阶段提交改进"></a>三阶段提交改进</h4><p>三阶段提交（canCommit、preCommit、doCommit）主要是为了解决TM单点故障和缩小阻塞范围</p>
<ul>
<li>TM和RM都引入超时机制</li>
<li>将prepare阶段再分成canCommit和preCommit</li>
</ul>
<h3 id="JTA规范"><a href="#JTA规范" class="headerlink" title="JTA规范"></a>JTA规范</h3><p>JTA（Java Transaction API）规范可以看作是XA规范的Java版，其把XA规范中规定的DTP模型交互接口抽象成Java接口中的方法。</p>
<p>JTA相较于DTP模型，又新增了一中角色——<strong>应用服务器（Application Server）</strong>，比如Websphere、WebLogic、Jboss</p>
<p>Tomcat等，其中除了Tomcat以外都实现了JTA规范，都能提供事务管理的功能。</p>
<p><em>JTA规范规定，事务管理器的功能应该由Application Server提供</em>。</p>
<h4 id="JTA接口"><a href="#JTA接口" class="headerlink" title="JTA接口"></a>JTA接口</h4><p>TM供应商实现UserTransaction、TransactionManager、Transaction、TransactionSynchronizationRegistry、Synchronization、Xid接口，通过与XAResource接口交互来实现分布式事务；</p>
<p>RM供应商（比如mysql）实现XAResource接口；</p>
<p>Application只需要使用TM提供的UserTransaction接口，进行事务操作即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.transaction.Status：事务状态，这个接口主要是定义一些表示事务状态的常量，此接口无需实现</span><br><span class="line"></span><br><span class="line">javax.transaction.Synchronization：同步</span><br><span class="line"></span><br><span class="line">javax.transaction.Transaction：事务</span><br><span class="line"></span><br><span class="line">javax.transaction.TransactionManager：事务管理器</span><br><span class="line"></span><br><span class="line">javax.transaction.UserTransaction：用于声明一个分布式事务</span><br><span class="line"></span><br><span class="line">javax.transaction.TransactionSynchronizationRegistry：事务同步注册</span><br><span class="line"></span><br><span class="line">javax.transaction.xa.XAResource：定义RM提供给TM操作的接口</span><br><span class="line"></span><br><span class="line">javax.transaction.xa.Xid：事务id</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/fwm123/pictures-repo/raw/master/blog-images/20220512193934.png" alt="image-20220512193932400"></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> feng.test.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atomikos.icatch.jta.UserTransactionImp;</span><br><span class="line"><span class="keyword">import</span> com.atomikos.jdbc.AtomikosDataSourceBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.transaction.UserTransaction;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomikosDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomikosDataSourceBean dataSource = createAtomikosDatasource(<span class="string">&quot;test_db&quot;</span>);</span><br><span class="line">        AtomikosDataSourceBean dataSource1 = createAtomikosDatasource(<span class="string">&quot;test_db_1&quot;</span>);</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Connection conn1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps1 = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        UserTransaction userTransaction = <span class="keyword">new</span> UserTransactionImp();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            userTransaction.begin();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//操作db</span></span><br><span class="line">            conn = dataSource.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(<span class="string">&quot;INSERT into user(name) VALUES (?)&quot;</span>, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;fwm&quot;</span>);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">            ResultSet rs = ps.getGeneratedKeys();</span><br><span class="line">            <span class="keyword">int</span> userId = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                userId = rs.getInt(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mock exception</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//操作db1</span></span><br><span class="line">            conn1 = dataSource1.getConnection();</span><br><span class="line">            ps1 = conn1.prepareStatement(<span class="string">&quot;INSERT into account(user_id,money) VALUES (?,?)&quot;</span>);</span><br><span class="line">            ps1.setInt(<span class="number">1</span>, userId);</span><br><span class="line">            ps1.setDouble(<span class="number">2</span>, <span class="number">10000000</span>);</span><br><span class="line">            ps1.executeUpdate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//两阶段提交</span></span><br><span class="line">            userTransaction.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">            ps1.close();</span><br><span class="line">            conn.close();</span><br><span class="line">            conn1.close();</span><br><span class="line">            dataSource.close();</span><br><span class="line">            dataSource1.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AtomikosDataSourceBean <span class="title">createAtomikosDatasource</span><span class="params">(String dbName)</span> </span>&#123;</span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        p.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:mysql://localhost:3306/&quot;</span> + dbName);</span><br><span class="line">        p.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        AtomikosDataSourceBean dataSourceBean = <span class="keyword">new</span> AtomikosDataSourceBean();</span><br><span class="line">        dataSourceBean.setUniqueResourceName(dbName);</span><br><span class="line">        dataSourceBean.setXaDataSourceClassName(<span class="string">&quot;com.mysql.jdbc.jdbc2.optional.MysqlXADataSource&quot;</span>);</span><br><span class="line">        dataSourceBean.setXaProperties(p);</span><br><span class="line">        <span class="keyword">return</span> dataSourceBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h3><h4 id="1-最大努力通知"><a href="#1-最大努力通知" class="headerlink" title="1.最大努力通知"></a>1.最大努力通知</h4><p>最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知等。最大努力通知型的实现方案，一般符合以下特点：</p>
<ul>
<li>不可靠消息：业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。</li>
<li>定期校对：业务活动的被动方，根据定时策略，向业务活动主动方查询(主动方提供查询接口)，恢复丢失的业务消息。</li>
</ul>
<h4 id="2-TCC两阶段补偿"><a href="#2-TCC两阶段补偿" class="headerlink" title="2.TCC两阶段补偿"></a>2.TCC两阶段补偿</h4><p>TCC的作用主要是解决<strong>跨服务调用场景下的分布式事务</strong>问题。</p>
<ul>
<li>Try 完成业务检查，预留业务资源</li>
<li>Confirm 使用预留的资源执行业务操作</li>
<li>Cancel 取消预留的业务资源</li>
</ul>
<h5 id="TCC-与-两阶段提交"><a href="#TCC-与-两阶段提交" class="headerlink" title="TCC 与 两阶段提交"></a>TCC 与 两阶段提交</h5><ol>
<li>在阶段1</li>
</ol>
<p>​     XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；</p>
<p>​     TCC中，是主业务活动请求(try)各个从业务服务预留资源。</p>
<ol start="2">
<li>在阶段2</li>
</ol>
<p>​    XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支；</p>
<p>   TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。</p>
<p>TCC两阶段提交与XA两阶段提交的区别是：</p>
<p><strong>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。</strong> XA事务中的两阶段提交内部过程是对开发者屏蔽的，一般由TM、RM的供应商实现二阶段提交的逻辑，开发者从代码层面是感知不到这个过程。事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。</p>
<p><strong>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。</strong>TCC的每个阶段都需要业务代码参与，同时每个阶段都是由独立的本地事务执行，因此不会对资源一直加锁。Confirm/Cancel相当于补偿性事务（通过一个独立的事务确定/回滚上一个独立事务Try的结果）</p>
<h5 id="TCC的优缺点"><a href="#TCC的优缺点" class="headerlink" title="TCC的优缺点"></a>TCC的优缺点</h5><p>优点：XA两阶段提交资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现。有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能问题。</p>
<p>缺点：主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。原来只需要提供一个接口，现在需要改造成try、confirm、canel3个接口，开发成本高。</p>
<h4 id="3-可靠消息最终一致性"><a href="#3-可靠消息最终一致性" class="headerlink" title="3.可靠消息最终一致性"></a>3.可靠消息最终一致性</h4><p>消息发送一致性：产生消息的业务操作和消息发送必须一致。如果业务操作成功，那么由这个业务操作所产生的消息一定要成功投递出去，否则由消息中间件主动丢掉消息，不进行投递。</p>
<p>案例分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.先操作db，再发送消息; 这种情况无法保证一致性，不在一个事务里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	db.buy();</span><br><span class="line">	mq.send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.先发送消息，再操作db；同样无法保证一致性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mq.send();</span><br><span class="line">	db.buy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.先发送消息，再操作db，且在一个事务里；无法保证一致性，如果db异常，mq消息无法回滚</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mq.send();</span><br><span class="line">	db.buy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.先操作db，再发送消息，且在一个事务里；看似没有问题，mq异常会回滚db</span></span><br><span class="line"><span class="comment">//但是发送mq消息可能事实上已经成功，如果是响应超时导致的异常。这个时候，数据库操作依然回滚，但是MQ消息实际上已经发送成功，导致不一致</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	db.buy();</span><br><span class="line">	mq.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JTA事务管理器"><a href="#JTA事务管理器" class="headerlink" title="JTA事务管理器"></a>JTA事务管理器</h5><p>Spring还提供了另外一个分布式事务管理器<code>JtaTransactionManager</code>。这个是使用XA两阶段提交来保证事务的一致性。当然前提是，你的消息中间件是实现了JMS规范中事务消息相关API。</p>
<p>但不建议这么做，消息中间件本来就是为了异步解耦，如今把他糅合进事务里，大大降低了性能。</p>
<p>那么如何保证，数据库操作和消息发送的一致性呢？</p>
<h5 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h5><p><img src="https://gitee.com/fwm123/pictures-repo/raw/master/blog-images/20220513104308.png" alt="BE2326B0-FC19-4620-BD2E-D34A32B8A405.png"></p>
<ol>
<li>发送一个事务消息，这个时候，RocketMQ将消息状态标记为Prepared，此时这条消息还没有真正投递，消费者是无法消费到</li>
<li>执行业务代码逻辑，可能是一个本地数据库事务操作</li>
<li>确认发送消息，这个时候，RocketMQ将消息状态标记为可消费，这个时候消费者，才能真正的保证消费到这条数据</li>
</ol>
<ul>
<li><p>如果确认消息发送失败了怎么办？</p>
<p>RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
</li>
<li><p> 如果消费失败怎么办？</p>
</li>
</ul>
<p>  人工补偿解决</p>
<h5 id="本地事务表"><a href="#本地事务表" class="headerlink" title="本地事务表"></a>本地事务表</h5><p>如果MQ不支持事务消息，可以用本地事务表实现类似的功能。</p>
<ol>
<li>Producer开始执行业务，向本地事务表里插入一条prepared消息记录，</li>
<li>Producer执行db事务，成功的话发送mq消息，否则删除本地事务表里的记录，</li>
<li>监听mq发送回调，如果回调成功，将prepared状态更新为committed状态</li>
<li>同时启动一个定时任务，扫描prepared消息记录，根据业务规则进行mq补偿或直接删除。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>分库分表及其事务问题</title>
    <url>/2022/04/16/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%8A%E5%85%B6%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h2><p>分库：单库数据量太大，达到了mysql或机器的磁盘空间、IO瓶颈</p>
<p>分表：单表数据量太大，即使有索引还是查询慢，且数据量一直增加。表中存在过大字段（MEDIUMTEXT、LONGTEXT等）</p>
<h2 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title="如何分库分表"></a>如何分库分表</h2><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直分库：根据业务边界划分，把不同业务表放到不同的库中</p>
<p>垂直分表：1）根据使用频率拆分字段；2）根据字段大小拆分字段，能减少磁盘IO</p>
<p>优点：</p>
<ul>
<li>降低业务耦合度</li>
<li>数据库物理资源分开，方便后续业务扩展</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果要看完整行数据，可能需要join多张表</li>
<li>保存数据多个表，涉及到分布式事务</li>
</ul>
<h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平分库：单表数据量过大，将数据按照一定规则，放到不同表中。</p>
<p>水平分表策略：</p>
<ul>
<li>按照自增id范围分表</li>
<li>按照时间区间分表</li>
<li>哈希取模分表，根据userid切分，需要考虑扩容时数据迁移的复杂性，考虑一致性hash</li>
</ul>
<h2 id="全局主键问题"><a href="#全局主键问题" class="headerlink" title="全局主键问题"></a>全局主键问题</h2><ul>
<li>UUID</li>
<li>一个额外的自增ID表</li>
<li>雪花算法</li>
</ul>
<h2 id="事务一致性问题"><a href="#事务一致性问题" class="headerlink" title="事务一致性问题"></a>事务一致性问题</h2><p>分库之后，对数据的修改可能涉及多个库，此时只靠db的事务是没法保证数据一致性的，需要引入分布式事务解决方案，比如XA协议、2PC、3PC协议进行事务的提交。</p>
<p>分布式事务虽然能保证跨库更新的原子性，但同时也带来了延迟，提高死锁的几率。所以，如果不要求强一致性，可以考虑采用事务（日志）补偿的方式达到最终一致性。</p>
<h3 id="典型的分布式事务解决方案"><a href="#典型的分布式事务解决方案" class="headerlink" title="典型的分布式事务解决方案"></a>典型的分布式事务解决方案</h3><h4 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h4><p>2PC即为两阶段提交，是一种在多节点间实现事务原子提交的算法，用来确保所有节点要么全部提交，要么全部中止。我们可以有多种方案来实现该算法，如基于XA协议的实现，阿里也提供了Seata中间件支持2PC算法。</p>
<p><strong>准备阶段：</strong> 协调者会在准备阶段给所有参与者都发送准备命令。如果参与者发现准备命令无法执行或者执行失败时，可以返回失败，如果执行完成则保存事务日志并返回成功。针对于数据库的操作，准备阶段会记录redolog以及undolog为后续的提交做准备。需要注意的是<strong>在准备阶段时，数据实际是没有被真正保存的</strong>。</p>
<p><strong>提交阶段：</strong> 协调者在提交阶段会根据准备阶段各个参与者的返回结果，判断是执行事务还是回滚事务并向所有参与者发起提交命令。</p>
<p>优点：</p>
<ul>
<li>事务强一致性</li>
<li>实现相对简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>同步阻塞问题，其中一个节点相应慢或者超时，其他节点都得等它</li>
<li>增大死锁几率，事务从准备阶段到完成一直锁定资源</li>
<li>事务协调者单点故障风险</li>
</ul>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>TCC分别指的是三个步骤，Try - Confirm - Cancel。与2PC类似，它在逻辑也会分成准备和提交两个阶段。但是最大的不同在于<strong>TCC需要业务服务自己去实现准备、执行、回滚的代码，因此可以做到非常灵活。</strong></p>
<p>Try——对资源进行锁定； Confirm——执行事务；Cancel——回滚事务，取消锁定</p>
<p>其实TCC本质还是2PC，只是2PC针对于db操作，而TCC可以让业务实现每个阶段的操作，更加灵活。</p>
<p>优点：实现灵活，</p>
<p>缺点：代码耦合度搞，改造难度大；包含2PC的所有缺点</p>
<p>参考：<a href="https://github.com/dromara/hmily">https://github.com/dromara/hmily</a></p>
<h4 id="最大努力通知（本地消息表）"><a href="#最大努力通知（本地消息表）" class="headerlink" title="最大努力通知（本地消息表）"></a>最大努力通知（本地消息表）</h4><p>本地消息表其实就是使用了一张额外的表保存了事务操作的日志，通过定时检查日志表中的失败日志并重试，以此达到最终一致性。</p>
<p>优点：</p>
<ul>
<li>不会长时间锁住资源，减少死锁风险</li>
<li>避免长事务，提高吞吐量</li>
</ul>
<p>缺点：不能保证强一致性</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>2PC</strong> 是强一致性的事务，适合用在数据库层面。</p>
<p><strong>TCC</strong> 也是强一致性的事务，适合大部分场景，但是对业务代码有侵入，开发量也很大。</p>
<p><strong>最大努力通知</strong> 是最终一致性事务。</p>
<p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/264847518">https://zhuanlan.zhihu.com/p/264847518</a></p>
<p><a href="https://github.com/dromara/hmily">https://github.com/dromara/hmily</a></p>
<p><a href="https://www.diaosi.love/archives/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1#toc-head-15">https://www.diaosi.love/archives/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1#toc-head-15</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>动态线程池实现思路</title>
    <url>/2022/04/19/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="jdk线程池分析"><a href="#jdk线程池分析" class="headerlink" title="jdk线程池分析"></a>jdk线程池分析</h2><h4 id="如何执行任务"><a href="#如何执行任务" class="headerlink" title="如何执行任务"></a>如何执行任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor#<span class="function">execute</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//线程池利用AtomicInteger 一个ctl变量来同时保存当前池状态（高3位）和当前池线程数（低29位）</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="comment">//1.如果当前线程数 &lt; 核心线程池，则新建一个线程来处理提交的任务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">//2.线程池处于非running状态，从任务队列移除任务并执行拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.如果当前线程数 &gt; 核心线程数且任务队列没满，则将任务放入任务队列等待执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">//4.如果当前线程数 &gt; 最大线程数，且队列已满，则拒绝该任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Woker线程管理"><a href="#Woker线程管理" class="headerlink" title="Woker线程管理"></a>Woker线程管理</h4><p>Worker是线程池内的工作线程</p>
<ol>
<li>继承了AQS（执行时通过锁住worker对象表示任务正在执行中，并且是不可重入的）</li>
<li>实现了Runnable接口，在run方法里循环从任务队列获取任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null。为null表示非核心线程</span></span><br><span class="line">    </span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/04/21/uPRDxwmzYApgtif.png" alt="03268b9dc49bd30bb63064421bb036bf90315"></p>
<h5 id="非核心线程如何回收"><a href="#非核心线程如何回收" class="headerlink" title="非核心线程如何回收"></a>非核心线程如何回收</h5><p>线程池中线程的销毁依赖JVM自动的回收，ThreadPoolExecutor<strong>通过一个hashset持有线程的引用</strong>，防止这些线程被回收。对于需要回收的线程，只要移除引用即可。</p>
<p>在addWorker方法中，如果Worker创建成功，会将worker的引用添加到workers一个hashset里面，非核心线程在拉取任务超时后，会执行processWorkerExit，将自己的引用从workers里面移除，之后就交给gc去回收线程。</p>
<h5 id="如何判断worker线程的状态"><a href="#如何判断worker线程的状态" class="headerlink" title="如何判断worker线程的状态"></a>如何判断worker线程的状态</h5><p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。如果正在执行任务，则不应该中断线程</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会<strong>使用tryLock方法来判断线程池中的线程是否是空闲状态</strong>；如果线程是空闲状态则可以安全回收。</li>
</ol>
<p><img src="C:\Users\15118\Desktop\9d8dc9cebe59122127460f81a98894bb34085.png" alt="图8 线程池回收过程"></p>
<p>参考：<a href="https://juejin.cn/post/7073286368629096485">https://juejin.cn/post/7073286368629096485</a></p>
]]></content>
  </entry>
  <entry>
    <title>接口幂等性方案</title>
    <url>/2022/03/29/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="什么是接口幂等性"><a href="#什么是接口幂等性" class="headerlink" title="什么是接口幂等性"></a>什么是接口幂等性</h2><p>同一个接口，被调用多次时，必须保证操作只执行一次。</p>
<p>场景：用户重复点击，网络请求失败导致重试等</p>
<h2 id="如何保证幂等性"><a href="#如何保证幂等性" class="headerlink" title="如何保证幂等性"></a>如何保证幂等性</h2><p>唯一索引</p>
<p>乐观锁</p>
<p>分布式锁</p>
<p>合理设置状态机（状态流转图）</p>
<p>全局唯一ID</p>
<p>防重表：</p>
<p>​    使用唯一主键去做防重表的唯一索引,比如使用订单号作为防重表的唯一索引,每一次请求都根据订单号向防重表中插入一条数据,插入成功说明可以处理后面的业务,当处理完业务逻辑之后删除防重表中的订单号数据,后续如果有重复请求,则会因为防重表唯一索引原因导致插入失败,直接返回操作失败,直到第一次请求返回结果,可以看出防重表作用就是加锁的功能。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>幂等</tag>
      </tags>
  </entry>
  <entry>
    <title>disruptor探索</title>
    <url>/2021/10/30/disruptor%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="从Logger4j2引出Disruptor"><a href="#从Logger4j2引出Disruptor" class="headerlink" title="从Logger4j2引出Disruptor"></a>从Logger4j2引出Disruptor</h2><p>最近把日志框架从logback切换到了log4j2，号称在多线程环境下性能优于log4j和logback数十倍，下面是log4j2官网提供的经典峰值吞吐量对比图。Log4j 2的 Async Loggers 支持使用无锁数据结构（Disruptor），而 Logback、 Log4j 则只支持 ArrayBlockingQueue，多线程下无法避免锁争用，从而导致吞吐量大大降低。<br><img src="https://i.loli.net/2021/10/31/HzdbZD95w4CFip1.png" alt="image-20211031110132988"></p>
<h2 id="Disruptor是什么"><a href="#Disruptor是什么" class="headerlink" title="Disruptor是什么"></a>Disruptor是什么</h2><blockquote>
<p>Disruptor是一个高性能的无锁并发框架，提供了一种线程消息传递的方式。</p>
</blockquote>
<h2 id="为什么有Disruptor"><a href="#为什么有Disruptor" class="headerlink" title="为什么有Disruptor"></a>为什么有Disruptor</h2><p>介绍Disruptor之前，我们先来看一看常用的线程安全的内置队列有什么问题。</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>有界性</th>
<th>锁结构</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>unbounded</td>
<td>无锁（CAS）</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>无锁（CAS）</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
</tbody></table>
<h3 id="ArrayBlockingQueue的缺点"><a href="#ArrayBlockingQueue的缺点" class="headerlink" title="ArrayBlockingQueue的缺点"></a>ArrayBlockingQueue的缺点</h3><h4 id="加锁性能损耗"><a href="#加锁性能损耗" class="headerlink" title="加锁性能损耗"></a>加锁性能损耗</h4><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><h6 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h6><p>首先了解计算机CPU缓存基本结构。L1缓存、L2缓存、L3缓存、主存，容量依次增大，访问速度依次减小。CPU读取主存中的数据会比从L1中读取慢2个数量级。</p>
<table>
<thead>
<tr>
<th>从CPU到</th>
<th><strong>大约需要的CPU周期</strong></th>
<th><strong>大约需要的时间</strong></th>
</tr>
</thead>
<tbody><tr>
<td>主存</td>
<td>-</td>
<td>约60-80ns</td>
</tr>
<tr>
<td>QPI 总线传输(between sockets, not drawn)</td>
<td>-</td>
<td>约20ns</td>
</tr>
<tr>
<td>L3 cache</td>
<td>约40-45 cycles</td>
<td>约15ns</td>
</tr>
<tr>
<td>L2 cache</td>
<td>约10 cycles</td>
<td>约3ns</td>
</tr>
<tr>
<td>L1 cache</td>
<td>约3-4 cycles</td>
<td>约1ns</td>
</tr>
<tr>
<td>寄存器</td>
<td>1 cycle</td>
<td>-</td>
</tr>
</tbody></table>
<h6 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h6><p>Cache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。</p>
<p>ArrayBlockingQueue有三个成员变量：</p>
<ul>
<li>takeIndex：需要被取走的元素下标 </li>
<li> putIndex：可被元素插入的位置的下标 </li>
<li> count：队列中元素的数量</li>
</ul>
<p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。<strong>所以每次修改，都会使之前缓存的数据失效</strong>，从而不能完全达到共享的效果。当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。<strong>这种无法充分使用缓存行特性的现象，称为伪共享</strong>。</p>
<p>对于伪共享，一般的解决方案是，<strong>增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上</strong>，以空间换时间。</p>
<h2 id="Disruptor的设计方案"><a href="#Disruptor的设计方案" class="headerlink" title="Disruptor的设计方案"></a>Disruptor的设计方案</h2><ul>
<li>环形数组。采用数组而非链表。数组对处理器的缓存机制更加友好</li>
<li>元素定位采用位运算。数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</li>
<li>无锁设计。每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</li>
</ul>
<h4 id="单个生产者"><a href="#单个生产者" class="headerlink" title="单个生产者"></a>单个生产者</h4><ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li>
<li>若是返回的正确，则生产者开始写入元素。</li>
</ol>
<img src="https://i.loli.net/2021/11/27/2g9kZhAzeI8JNG1.png" alt="image-20211127161425403" style="zoom: 67%;" />

<img src="https://i.loli.net/2021/11/27/qXOAkbCV5EScghT.png" alt="image-20211127161506809" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.lmax.disruptor.SingleProducerSequencer#next(int)</span></span><br><span class="line"><span class="comment">//获取下一个可用的index</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;n must be &gt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> nextValue = <span class="keyword">this</span>.nextValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> nextSequence = nextValue + n;</span><br><span class="line">    <span class="keyword">long</span> wrapPoint = nextSequence - bufferSize;</span><br><span class="line">    <span class="keyword">long</span> cachedGatingSequence = <span class="keyword">this</span>.cachedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue)</span><br><span class="line">    &#123;</span><br><span class="line">        cursor.setVolatile(nextValue);  <span class="comment">// StoreLoad fence</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> minSequence;</span><br><span class="line">        <span class="keyword">while</span> (wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue)))</span><br><span class="line">        &#123;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">1L</span>); <span class="comment">// <span class="doctag">TODO:</span> Use waitStrategy to spin?</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.cachedValue = minSequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextValue = nextSequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h4><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，<strong>每个线程获取不同的一段数组空间进行操作</strong>。这个通过CAS很容易达到。<strong>只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可</strong>。</p>
<p>但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：<strong>available Buffer</strong>。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。<strong>读取的时候，会遍历available Buffer，来判断元素是否已经就绪</strong>。</p>
<h5 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h5><ol>
<li>申请读取到序号n；</li>
<li>若writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；</li>
<li>消费者读取元素。</li>
</ol>
<p>如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。</p>
<p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。因此，消费者读取下标从3到6共计4个元素。</p>
<p><img src="https://i.loli.net/2021/11/27/R3TkwUDjHZsA8dn.png" alt="image-20211127162333405"></p>
<h5 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h5><ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li>
<li>生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。</li>
</ol>
<p>如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</p>
<p>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</p>
<p><img src="https://i.loli.net/2021/11/27/X8l3DmSkHco1uA6.png" alt="image-20211127162555454"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;n must be &gt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> current;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        current = cursor.get();</span><br><span class="line">        next = current + n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> wrapPoint = next - bufferSize;</span><br><span class="line">        <span class="keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> gatingSequence = Util.getMinimumSequence(gatingSequences, current);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (wrapPoint &gt; gatingSequence)</span><br><span class="line">            &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1</span>); <span class="comment">// TODO, should we spin based on the wait strategy?</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gatingSequenceCache.set(gatingSequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cursor.compareAndSet(current, next))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Disruptor源码初探"><a href="#Disruptor源码初探" class="headerlink" title="Disruptor源码初探"></a>Disruptor源码初探</h2><p><img src="https://i.loli.net/2021/11/27/1mvxdBl67eziOcI.png" alt="image-20211127181001523"></p>
<h3 id="相关类和接口"><a href="#相关类和接口" class="headerlink" title="相关类和接口"></a>相关类和接口</h3><ul>
<li><strong>Sequenced</strong> 环形缓存区与序号相关的操作。<ul>
<li>int getBufferSize() 获取缓存区大小</li>
<li>boolean hasAvailableCapacity(int requiredCapacity) 是否还有requiredCapacity个空间供写入线程写入数据</li>
<li>long remainingCapacity() 当前剩余容量</li>
<li>long next() 获取下一个可写入的下标</li>
<li>long next(int n) 从环形队列中获取n个可用的下标，返回值为这批最大的可写入序号</li>
<li>long tryNext() throws InsufficientCapacityException 尝试从环形队列中获取一个可写入位置，如果没有空闲位置供写入则抛出异常</li>
<li>long tryNext(int n) throws InsufficientCapacityException 尝试从环形队列中获取n个可写入位置，如果没有空闲位置供写入则抛出异常</li>
<li>void publish(long sequence) 将处于下标sequence的位置“发布”，此时消费者可以从环形队列中消费</li>
<li>void publish(long lo, long hi) 将从 lo 到 hi 的下标之间的数据发布</li>
</ul>
</li>
<li><strong>DataProvider</strong> 数据提供者，只提供了根据下标位置获取数据</li>
<li>**Cursored **游标，当前处理的下标</li>
<li>**EventSink **数据 sink，主要是提供了丰富的publish方法</li>
<li><strong>RingBufferPad</strong>、<strong>RingBufferFields</strong> 填充实现，主要解决“伪共享”</li>
<li><strong>RingBuffer</strong> 环形缓存区实现类</li>
</ul>
<h3 id="RingBuffer解决伪共享"><a href="#RingBuffer解决伪共享" class="headerlink" title="RingBuffer解决伪共享"></a>RingBuffer解决伪共享</h3><p>在RingBuffer中环形队列在底层需要维护一个存储数组，那么要保证数组中的每个下标都不要和其他无关变量缓存到同一个cache line中，通常的办法是通常的方案是在前后数组填充128个字节（理论上只要64字节？）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//返回当前jvm中用来表示一个数组下标占用的字节数，64位操作系统开启了指针压缩将返回4，否则返回8，默认开启了指针压缩。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scale = UNSAFE.arrayIndexScale(Object[].class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> == scale)</span><br><span class="line">    &#123;</span><br><span class="line">        REF_ELEMENT_SHIFT = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">8</span> == scale)</span><br><span class="line">    &#123;</span><br><span class="line">        REF_ELEMENT_SHIFT = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unknown pointer size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BUFFER_PAD = <span class="number">128</span> / scale;</span><br><span class="line">    <span class="comment">// Including the buffer pad in the array base offset</span></span><br><span class="line">    <span class="comment">// UNSAFE.arrayBaseOffset可以获取数组的起始位置</span></span><br><span class="line">    REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + (BUFFER_PAD &lt;&lt; REF_ELEMENT_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/27/Bqj1v5TpzWrJIyF.png" alt="image-20211127170539836"></p>
<h3 id="无锁化实现"><a href="#无锁化实现" class="headerlink" title="无锁化实现"></a>无锁化实现</h3><p>Disruptor写数据模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取下一个可写的下标</span></span><br><span class="line"><span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//从ringbuffer中拿出此下标对应的</span></span><br><span class="line">	Event e = ringBuffer.get(sequence);</span><br><span class="line">	<span class="comment">// Do some work with the event.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	ringBuffer.publish(sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RingBuffer#next()直接调用sequencer#next()</p>
<h4 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h4><p><strong>MultiProducerSequencer</strong>、<strong>SingleProducerSequencer</strong>两个具体的实现，也是Disruptor实现无锁化的核心要点。</p>
<p><img src="https://i.loli.net/2021/11/27/mTvM4R1bZJ9gB8P.png" alt="image-20211127172622598"></p>
<h4 id="环形队列写数据原理"><a href="#环形队列写数据原理" class="headerlink" title="环形队列写数据原理"></a>环形队列写数据原理</h4><p>环形队列，就是对数组进行重复利用，当writeIndex移动到队列最后一个位置再+1时，会移动到队列开头重新写入，因此会有数据覆盖的问题。如果队列开头的元素暂未被读取，那么直接覆盖掉就丢失数据了。为了避免这种情况，需要增加对writeIndex和readIndex约束，readIndex表示第一条待读取的位置：<br>$$<br>writeIndex - readIndex &lt; bufferSize<br>$$<br>知道这个条件后再继续看<strong>MultiProducerSequencer#next</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> Sequencer#next(int)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;n must be &gt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> current;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//环形队列已使用的最大序号，下一个可写序号从 cursor + 1 开始</span></span><br><span class="line">        current = cursor.get();</span><br><span class="line">        next = current + n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">long</span> wrapPoint = next - bufferSize;</span><br><span class="line">        <span class="comment">//消费端已处理的最小序列号，即环形队列中的readIndex</span></span><br><span class="line">        <span class="keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果暂时不能写入序号</span></span><br><span class="line">        <span class="keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> gatingSequence = Util.getMinimumSequence(gatingSequences, current);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (wrapPoint &gt; gatingSequence)</span><br><span class="line">            &#123;</span><br><span class="line">                LockSupport.parkNanos(<span class="number">1</span>); <span class="comment">// TODO, should we spin based on the wait strategy?</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gatingSequenceCache.set(gatingSequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cursor.compareAndSet(current, next))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用CAS命令尝试更新，如果更新成功，则返回next给Producer</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多个Consumer读数据"><a href="#多个Consumer读数据" class="headerlink" title="多个Consumer读数据"></a>多个Consumer读数据</h4><p>在disruptor中，并发消费的实现类有<strong>WorkerPool</strong>、<strong>BatchEventProcessor</strong></p>
<h5 id="WorkerPool"><a href="#WorkerPool" class="headerlink" title="WorkerPool"></a>WorkerPool</h5><p>WorkerPool中<strong>每一个线程一次只处理一个序号</strong></p>
<p>WorkerPool中有多个WorkProcessor，具体看WorkProcessor#run方法</p>
<ul>
<li>nextSequence 每一个WorkerPool维护一个整体的处理进度序号，会被多个WorkProcessor共同竞争获取</li>
<li>sequence 每一个WorkProcessor内部会维护一个当前已处理的序号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!running.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Thread is already running&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       sequenceBarrier.clearAlert();</span><br><span class="line"></span><br><span class="line">       notifyStart();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> processedSequence = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">long</span> cachedAvailableSequence = Long.MIN_VALUE;</span><br><span class="line">       <span class="keyword">long</span> nextSequence = sequence.get();</span><br><span class="line">       T event = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// if previous sequence was processed - fetch the next sequence and set</span></span><br><span class="line">               <span class="comment">// that we have successfully processed the previous sequence</span></span><br><span class="line">               <span class="comment">// typically, this will be true</span></span><br><span class="line">               <span class="comment">// this prevents the sequence getting too far forward if an exception</span></span><br><span class="line">               <span class="comment">// is thrown from the WorkHandler</span></span><br><span class="line">               <span class="keyword">if</span> (processedSequence)</span><br><span class="line">               &#123;</span><br><span class="line">                   processedSequence = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="comment">// (1) 通过while+CAS获取整个WorkerPool的下一个待处理的下标nextSequence</span></span><br><span class="line">                   <span class="keyword">do</span></span><br><span class="line">                   &#123;</span><br><span class="line">                       nextSequence = workSequence.get() + <span class="number">1L</span>;</span><br><span class="line">                       sequence.set(nextSequence - <span class="number">1L</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">while</span> (!workSequence.compareAndSet(nextSequence - <span class="number">1L</span>, nextSequence));</span><br><span class="line">               &#125;</span><br><span class="line">			<span class="comment">// (2)如果当前可处理的序号大于等于nextSequence，即可处理该序号中的数据，</span></span><br><span class="line">               <span class="comment">// 否则通过barrier的waitFor等待待处理序号可用，即等待Producer发布该序号</span></span><br><span class="line">               <span class="keyword">if</span> (cachedAvailableSequence &gt;= nextSequence)</span><br><span class="line">               &#123;</span><br><span class="line">                   event = ringBuffer.get(nextSequence);</span><br><span class="line">                   workHandler.onEvent(event);</span><br><span class="line">                   processedSequence = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   cachedAvailableSequence = sequenceBarrier.waitFor(nextSequence);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (<span class="keyword">final</span> TimeoutException e)</span><br><span class="line">           &#123;</span><br><span class="line">               notifyTimeout(sequence.get());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (<span class="keyword">final</span> AlertException ex)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (!running.get())</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// handle, mark as processed, unless the exception handler threw an exception</span></span><br><span class="line">               exceptionHandler.handleEventException(ex, nextSequence, event);</span><br><span class="line">               processedSequence = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       notifyShutdown();</span><br><span class="line"></span><br><span class="line">       running.set(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="BatchEventProcessor"><a href="#BatchEventProcessor" class="headerlink" title="BatchEventProcessor"></a>BatchEventProcessor</h5><p>批处理实现，一次获取多个序号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvents</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T event = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">// 获取下一个可处理序号</span></span><br><span class="line">        <span class="keyword">long</span> nextSequence = sequence.get() + <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;	<span class="comment">//通过sequenceBarrier获取可用的序号availableSequence</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);</span><br><span class="line">                <span class="keyword">if</span> (batchStartAware != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    batchStartAware.onBatchStart(availableSequence - nextSequence + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//一次性处理多个序号，直到达到availableSequence</span></span><br><span class="line">                <span class="keyword">while</span> (nextSequence &lt;= availableSequence)</span><br><span class="line">                &#123;</span><br><span class="line">                    event = dataProvider.get(nextSequence);</span><br><span class="line">                    eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);</span><br><span class="line">                    nextSequence++;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//设置当前已经处理的序号</span></span><br><span class="line">                sequence.set(availableSequence);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (<span class="keyword">final</span> TimeoutException e)</span><br><span class="line">            &#123;</span><br><span class="line">                notifyTimeout(sequence.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (<span class="keyword">final</span> AlertException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (running.get() != RUNNING)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex)</span><br><span class="line">            &#123;</span><br><span class="line">                handleEventException(ex, nextSequence, event);</span><br><span class="line">                sequence.set(nextSequence);</span><br><span class="line">                nextSequence++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="log4j2使用Disruptor"><a href="#log4j2使用Disruptor" class="headerlink" title="log4j2使用Disruptor"></a>log4j2使用Disruptor</h2><h4 id="AsyncLogger-logWithThreadLocalTranslator"><a href="#AsyncLogger-logWithThreadLocalTranslator" class="headerlink" title="AsyncLogger#logWithThreadLocalTranslator"></a>AsyncLogger#logWithThreadLocalTranslator</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logWithThreadLocalTranslator</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> Level level, <span class="keyword">final</span> Marker marker,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> Message message, <span class="keyword">final</span> Throwable thrown)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation note: this method is tuned for performance. MODIFY WITH CARE!</span></span><br><span class="line">    <span class="keyword">final</span> RingBufferLogEventTranslator translator = getCachedTranslator();</span><br><span class="line">    initTranslator(translator, fqcn, level, marker, message, thrown);</span><br><span class="line">    initTranslatorThreadValues(translator);</span><br><span class="line">    publish(translator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到日志时间的发布交给了loggerDisruptor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(<span class="keyword">final</span> RingBufferLogEventTranslator translator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!loggerDisruptor.tryPublish(translator)) &#123;</span><br><span class="line">        handleRingBufferFull(translator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="AsyncLoggerDisruptor"><a href="#AsyncLoggerDisruptor" class="headerlink" title="AsyncLoggerDisruptor"></a>AsyncLoggerDisruptor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Disruptor&lt;RingBufferLogEvent&gt; disruptor;</span><br><span class="line"><span class="keyword">private</span> AsyncQueueFullPolicy asyncQueueFullPolicy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ringBufferSize;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	...</span><br><span class="line">    <span class="comment">//获取相关配置</span></span><br><span class="line">    ringBufferSize = DisruptorUtil.calculateRingBufferSize(<span class="string">&quot;AsyncLogger.RingBufferSize&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> WaitStrategy waitStrategy = DisruptorUtil.createWaitStrategy(<span class="string">&quot;AsyncLogger.WaitStrategy&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> ThreadFactory threadFactory = <span class="keyword">new</span> Log4jThreadFactory(<span class="string">&quot;AsyncLogger[&quot;</span> + contextName + <span class="string">&quot;]&quot;</span>, <span class="keyword">true</span>, Thread.NORM_PRIORITY) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread result = <span class="keyword">super</span>.newThread(r);</span><br><span class="line">            backgroundThreadId = result.getId();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    asyncQueueFullPolicy = AsyncQueueFullPolicyFactory.create();</span><br><span class="line">    <span class="comment">// 创建根据相关配置Disruptor</span></span><br><span class="line">    disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(RingBufferLogEvent.FACTORY, ringBufferSize, threadFactory, ProducerType.MULTI,</span><br><span class="line">                                waitStrategy);</span><br><span class="line">    <span class="comment">//设置异常处理器</span></span><br><span class="line">    <span class="keyword">final</span> ExceptionHandler&lt;RingBufferLogEvent&gt; errorHandler = DisruptorUtil.getAsyncLoggerExceptionHandler();</span><br><span class="line">    disruptor.setDefaultExceptionHandler(errorHandler);</span><br><span class="line">    <span class="comment">//设置事件处理器，这里是具体的日志处理逻辑</span></span><br><span class="line">    <span class="keyword">final</span> RingBufferLogEventHandler[] handlers = &#123;<span class="keyword">new</span> RingBufferLogEventHandler()&#125;;</span><br><span class="line">    disruptor.handleEventsWith(handlers);</span><br><span class="line">    <span class="comment">//启动Disruptor</span></span><br><span class="line">    disruptor.start();</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//AsyncLoggerDisruptor#tryPublish</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">tryPublish</span><span class="params">(<span class="keyword">final</span> RingBufferLogEventTranslator translator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Note: we deliberately access the volatile disruptor field afresh here.</span></span><br><span class="line">            <span class="comment">// Avoiding this and using an older reference could result in adding a log event to the disruptor after it</span></span><br><span class="line">            <span class="comment">// was shut down, which could cause the publishEvent method to hang and never return.</span></span><br><span class="line">            <span class="keyword">return</span> disruptor.getRingBuffer().tryPublishEvent(translator);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NullPointerException npe) &#123;</span><br><span class="line">            <span class="comment">// LOG4J2-639: catch NPE if disruptor field was set to null in stop()</span></span><br><span class="line">            logWarningOnNpeFromDisruptorPublish(translator);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过RingBufferLogEvent#onEvent最终调用最终的写日志逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actualAsyncLog</span><span class="params">(<span class="keyword">final</span> RingBufferLogEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LoggerConfig privateConfigLoggerConfig = privateConfig.loggerConfig;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Property&gt; properties = privateConfigLoggerConfig.getPropertyList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">            onPropertiesPresent(event, properties);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//最终写日志逻辑</span></span><br><span class="line">        privateConfigLoggerConfig.getReliabilityStrategy().log(<span class="keyword">this</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><em>参考</em></h2><p><a href="https://tech.meituan.com/2016/11/18/disruptor.html">https://tech.meituan.com/2016/11/18/disruptor.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/-7RXNf8d5bDywbTisXOXDw">https://mp.weixin.qq.com/s/-7RXNf8d5bDywbTisXOXDw</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID生成方法总结</title>
    <url>/2021/11/14/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="分布式ID特性"><a href="#分布式ID特性" class="headerlink" title="分布式ID特性"></a>分布式ID特性</h3><ul>
<li>全局唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>最好是有序递增</li>
</ul>
<h3 id="分布式ID实现方式"><a href="#分布式ID实现方式" class="headerlink" title="分布式ID实现方式"></a>分布式ID实现方式</h3><ul>
<li>UUID</li>
<li>数据库自增</li>
<li>号段模式</li>
<li>雪花算法</li>
<li>借助Redis</li>
</ul>
<h3 id="JDK的UUID"><a href="#JDK的UUID" class="headerlink" title="JDK的UUID"></a>JDK的UUID</h3><ul>
<li>优点：简单，性能，全球唯一性</li>
<li>缺点：字符串存储，可读性差，无序，数据库占用空间大且查询效率低</li>
</ul>
<h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3><p>使用数据库的主键不唯一特性保证唯一性。（使用MyISAM引擎是因为不会有update场景）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `SEQ_ID`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    id <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>单台数据库在高并发下很容易达到性能瓶颈且不能保证高可用，因此需要数据库<strong>双主模式集群</strong>，同时两个数据库设置主键的<strong>起始值</strong>和<strong>步长</strong></p>
<p>mysql1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p>mysql2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p>优点：唯一性保证，自增</p>
<p>缺点：mysql单点风险，集群模式扩容方案复杂，高并发能力有限</p>
<h3 id="基于数据库的号段模式（常用）"><a href="#基于数据库的号段模式（常用）" class="headerlink" title="基于数据库的号段模式（常用）"></a>基于数据库的号段模式（常用）</h3><ol>
<li>数据库自增ID模式下，每次获取ID都要访问一次数据库，造成数据库压力大</li>
<li>改为每次获取一个segment(step决定大小)号段的值，用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力</li>
<li> 各个业务不同的发号需求用app_tag字段来区分，每个app-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对app-tag分库分表就行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `segments`</span><br><span class="line">(</span><br><span class="line">    `app_tag`     <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `max_id`      <span class="type">BIGINT</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `step`        <span class="type">BIGINT</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `update_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`app_tag`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> segments(`app_tag`, `max_id`, `step`) <span class="keyword">VALUES</span> (<span class="string">&#x27;test_business&#x27;</span>, <span class="number">0</span>, <span class="number">100000</span>);</span><br></pre></td></tr></table></figure>

<p>架构图如下</p>
<p><img src="https://i.loli.net/2021/11/14/uMlwINXBT6kJEHh.png" alt="image-20211114111047924"></p>
<p>test_tag在第一台Leaf机器上是1-1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001-4000。同时数据库对应的app_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line">UPDATE <span class="keyword">table</span> <span class="keyword">SET</span> max_id<span class="operator">=</span>max_id<span class="operator">+</span>step <span class="keyword">WHERE</span> app_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> app_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是<strong>趋势递增</strong>的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID号码<strong>不够随机</strong>，通过id号相减能获取大概的id生成数量，泄露id数量的信息，<strong>不太安全</strong>。</li>
<li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li>
<li><strong>DB宕机会造成整个系统不可用</strong>。</li>
</ul>
<h4 id="双buffer优化"><a href="#双buffer优化" class="headerlink" title="双buffer优化"></a>双buffer优化</h4><p>如果等到号段用完再去mysql拿新的号段，可能会阻塞业务线程，且业务响应容易受到数据库性能或网络影响。</p>
<p>为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。</p>
<p>采用<strong>双buffer</strong>的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p>
<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p><img src="https://i.loli.net/2021/11/14/GNXkFMyxvTOj4SW.png" alt="image-20211114114923848"></p>
<p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。Snowflake ID组成结构：<code>符号位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p>
<ul>
<li>符号位（1bit）Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0</li>
<li>时间戳（41bit）毫秒级的时间，不建议存当前时间戳，而是用<code>当前时间戳 - 固定开始时间戳</code>的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以</li>
<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成<strong>4096</strong>个ID</li>
</ul>
<h4 id="雪花算法Java实现"><a href="#雪花算法Java实现" class="headerlink" title="雪花算法Java实现"></a>雪花算法Java实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlakeShortUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_TIMESTAMP = <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>;   <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>;     <span class="comment">//机器标识占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">5</span>; <span class="comment">//数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     * -1 == 1111 1111</span></span><br><span class="line"><span class="comment">     * -1 &lt;&lt; 12 == 1111 1111 0000 0000 0000</span></span><br><span class="line"><span class="comment">     * MAX_MACHINE_NUM == -1L ^ (-1L &lt;&lt; SEQUENCE_BIT)</span></span><br><span class="line"><span class="comment">     * 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">     * ^</span></span><br><span class="line"><span class="comment">     * 1111 1111 0000 0000 0000</span></span><br><span class="line"><span class="comment">     * =</span></span><br><span class="line"><span class="comment">     * 0000 0000 1111 1111 1111 == MAX_SEQUENCE</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------</span></span><br><span class="line"><span class="comment">     * MAX_SEQUENCE        = 0000 0000 1111 1111 1111</span></span><br><span class="line"><span class="comment">     * MAX_MACHINE_NUM     = 0000 0000 0000 0001 1111</span></span><br><span class="line"><span class="comment">     * MAX_DATA_CENTER_NUM = 0000 0000 0000 0001 1111</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATA_CENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> dataCenterId;  <span class="comment">//数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> machineId;     <span class="comment">//机器标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;  <span class="comment">//上一次时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mill = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastTimeStamp) &#123;</span><br><span class="line">            mill = getNewTimeStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterId 数据中心ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> machineId    机器标志ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlakeShortUrl</span><span class="params">(<span class="keyword">long</span> dataCenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;DtaCenterId can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;MachineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currTimeStamp = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currTimeStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimeStamp = currTimeStamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="comment">//时间戳部分</span></span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class="comment">//数据中心部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分</span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SnowFlakeShortUrl snowFlake = <span class="keyword">new</span> SnowFlakeShortUrl(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++) &#123;</span><br><span class="line">            <span class="comment">//10进制</span></span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="雪花算法时钟回拨问题"><a href="#雪花算法时钟回拨问题" class="headerlink" title="雪花算法时钟回拨问题"></a>雪花算法时钟回拨问题</h4><p>如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号。</p>
<ul>
<li><p>节点启动时，若zk节点存在，说明之前已经启动过。则用自身系统时间与<code>forever/$&#123;self&#125;</code>节点记录时间做比较，若小于<code>leaf_forever/$&#123;self&#125;</code>时间则认为机器时间发生了大步长回拨，服务启动失败</p>
</li>
<li><p>节点启动时，若zk节点不存在，说明是新增服务机器，直接创建<code>forever/$&#123;self&#125;</code>持久子节点，并写入当前机器系统时间；并且获取<code>temporary根节点</code>下所有子节点（其他服务机器的ipPort信息），通过rpc或http接口获取到其他所有机器的时间，计算出<code>时间戳平均值</code>。</p>
</li>
<li><p>如果<code>abs(时间戳平均值-当前机器系统时间) &lt; 阈值</code>，说明当前机器时间正常，启动服务并且写入到<code>temporary/$&#123;self&#125;</code>维持租约； 否则说明当前机器发生偏移，启动失败。</p>
</li>
<li><p>每隔一段时间(3s)上报自身系统时间写入<code>leaf_forever/$&#123;self&#125;</code></p>
</li>
</ul>
<p>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。</p>
<ul>
<li><strong>要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可</strong></li>
<li><strong>或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发生了回拨，此刻时间小于上次发号时间</span></span><br><span class="line"> <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">long</span> offset = lastTimestamp - timestamp;</span><br><span class="line">            <span class="keyword">if</span> (offset &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">//时间偏差大小小于5ms，则等待两倍时间</span></span><br><span class="line">                    thread_wait(offset &lt;&lt; <span class="number">1</span>);<span class="comment">//wait</span></span><br><span class="line">                    timestamp = getTimeStamp();</span><br><span class="line">                    <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">                       <span class="comment">//还是小于，抛异常并上报</span></span><br><span class="line">                        throwClockBackwardsEx(timestamp);</span><br><span class="line">                      &#125;    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span>  e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//throw</span></span><br><span class="line">                throwClockBackwardsEx(timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//分配ID     </span></span><br></pre></td></tr></table></figure>

<p>优点：全局唯一，高可用， 利用zookeeper解决时钟回拨问题，弱依赖zookeeper</p>
<p>缺点：依赖第三方组件，架构较为复杂</p>
<h4 id="雪花算法段号模式"><a href="#雪花算法段号模式" class="headerlink" title="雪花算法段号模式"></a>雪花算法段号模式</h4><p>雪花算法的sequence也可以采用段号模式，减少client去服务端拿id的次数。</p>
<h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><ul>
<li>利用一个队列存储多个id段，每个id段包含此id段的StartId和EndId</li>
<li>Client每次获取nextId时，先取出队列头的id段，如果当前id处于此id段范围内，只要把当前id段自增+1返回即可</li>
<li>如果当前id小于队列头id段的StartId， 则返回此StartId，因为这已经是能拿到的最小id</li>
<li>如果当前id大于队列头id段的EndId，说明此id段已经被取完了， 需要取下一个id段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> currentId;</span><br><span class="line"><span class="keyword">private</span> Queue&lt;IdSeg&gt; idSegments = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Long <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IdSeg first = idSegments.peek();</span><br><span class="line">    <span class="keyword">if</span>(first == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currentId &lt; first.startId()) &#123;</span><br><span class="line">        currentId = first.startId();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(first.startId() &lt;= currentId &amp;&amp; first.endId() &gt; currentId) &#123;</span><br><span class="line">        currentId++; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        idSegments.remove();</span><br><span class="line">        first = idSegments.peek();</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//所有的id段都用完了，从server重新拿去id段</span></span><br><span class="line">            getIdSegFromServer();</span><br><span class="line">            getNextId();</span><br><span class="line">        &#125;</span><br><span class="line">        currentId = first.startId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><ul>
<li>通过while+CAS生成id段返回给client</li>
<li>比较lastid的lastTimestamp和当前curTimestamp，如果curTimestamp &gt; lastTimestamp，那么sequence部分从0开始，取size个，则id段范围是[0，size]</li>
<li>如果curTimestamp == lastTimestamp，则 sequence = (lastSequence+ 1) &amp; SEQUENCE_MASK</li>
<li>如果curTimestamp &lt; lastTimestamp，说明发生了时钟回拨，抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上一次</span></span><br><span class="line"><span class="keyword">private</span> AtomicLong lastIdRef;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取id段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue&lt;IdSeg&gt; <span class="title">getIdSegments</span><span class="params">(<span class="keyword">int</span> fetchSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = fetchSize;</span><br><span class="line">    Queue&lt;IdSeg&gt; ids = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取下一个id段，预期id段的长度是size</span></span><br><span class="line">        IdSeg newIdSeg = getNextIdSegment(size);</span><br><span class="line">        <span class="keyword">if</span>(newIdSeg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ids.add(newIdSeg);</span><br><span class="line">            size -= newIdSeg.endId() - newIdSeg.startId() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ids;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下一个id段，段长度是size</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IdSeg <span class="title">getNextIdSegment</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> lastId = lastId.get();</span><br><span class="line">    <span class="keyword">long</span> lastTimestampt = getLastTimestampt();</span><br><span class="line">    <span class="keyword">long</span> curTimestampt = System.currentMillsTimestampt();</span><br><span class="line">    <span class="keyword">long</span> lastSequence = getLastSequence();</span><br><span class="line">    <span class="keyword">long</span> startSequence;</span><br><span class="line">    <span class="keyword">long</span> endSequence;</span><br><span class="line">    <span class="keyword">if</span>(curTimestamp &gt; lastTimestamp) &#123;</span><br><span class="line">        startSequence = <span class="number">0L</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curTimestamp &lt; lastTimestamp) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;发生了时钟回拨&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startSequence = (lastSequence + <span class="number">1</span>) &amp; SEQUENCE_MASK;</span><br><span class="line">        <span class="keyword">if</span>(startSequence == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明当前时间毫秒，序号已经取完，返回null重新获取</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curTimestamp = lastTimestampt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前时间戳下剩余序号大于size， 则序号取到startSequence + size - 1； 否则返回最大序号</span></span><br><span class="line">    <span class="keyword">if</span>(MAX_SEQUENCE - startSequence + <span class="number">1</span> &gt; size) &#123;</span><br><span class="line">        endSequence = startSequence + size - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        endSequence = MAX_SEQUENCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> endId = generateId(endSequence);</span><br><span class="line">    <span class="keyword">if</span>(lastIdRef.compareAndSet(lastId, endId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Idset(generateId(startSequence), endId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//CAS失败，说明有其他线程更新了lastId，返回null重新获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取雪花算法生成的id</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">generateId</span><span class="params">(<span class="keyword">long</span> sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="comment">//时间戳部分</span></span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class="comment">//数据中心部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分</span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="借助Redis"><a href="#借助Redis" class="headerlink" title="借助Redis"></a>借助Redis</h3><p>利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。需要考虑redis持久化的问题。</p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<p>优点：不依赖数据库，性能好</p>
<p>缺点：依赖第三方组件</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><em>参考</em></h3><p> <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">https://tech.meituan.com/2017/04/21/mt-leaf.html</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式ID</tag>
      </tags>
  </entry>
</search>
