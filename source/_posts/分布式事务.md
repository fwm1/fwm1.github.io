---
title: 分布式事务
date: 2022-05-09 20:55:45
tags:
categories:

---

### 分布式事务的典型场景

- 跨库事务
- 分库分表
- 跨服务调用场景下的分布式事务

### X/Open DTP模型

X/Open是一个国际的技术标准组织，提出了DTP（Distributed Transaction Processing）模型。DTP模型包含以下5中基本元素：

- 应用程序(Application Program ，AP)
- 资源管理器(Resource Manager，RM)，如数据库、文件系统
- 事务管理器(Resource Manager，TM)，负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚
- 通信资源管理器(Communication Resource Manager，CRM)
- 通信协议(Communication Protocol，CP)

### XA规范

XA规范的最主要的作用是，就是**定义了RM-TM的交互接口**，此外XA规范里也对二阶段提交的细节进行了优化和补充。

![1578CD5A-2EE1-4F41-8DE8-B2F615F79571.png](https://raw.githubusercontent.com/fwm1/PicturesRepo/master/blog-images/20220515222446.png)

*注：DTP模型中规定了全局事务的提交要使用二阶段提交，而XA规范中定义了二阶段提交的标准接口*

#### XA规范RM、TM标准交互接口

![img](https://raw.githubusercontent.com/fwm1/PicturesRepo/master/blog-images/20220515222452.png)

#### 二阶段提交的缺陷

- 同步阻塞
- TM单点故障，TM发生故障，RM会一直阻塞等待，无法完成事务
- 数据不一致，在提交阶段，部分机器执行了commit，另外一部分机器因为网络没有收到commit命令，导致数据不一致

#### 三阶段提交改进

三阶段提交（canCommit、preCommit、doCommit）主要是为了解决TM单点故障和缩小阻塞范围

- TM和RM都引入超时机制
- 将prepare阶段再分成canCommit和preCommit



### JTA规范

JTA（Java Transaction API）规范可以看作是XA规范的Java版，其把XA规范中规定的DTP模型交互接口抽象成Java接口中的方法。

JTA相较于DTP模型，又新增了一中角色——**应用服务器（Application Server）**，比如Websphere、WebLogic、Jboss

Tomcat等，其中除了Tomcat以外都实现了JTA规范，都能提供事务管理的功能。



*JTA规范规定，事务管理器的功能应该由Application Server提供*。



#### JTA接口

TM供应商实现UserTransaction、TransactionManager、Transaction、TransactionSynchronizationRegistry、Synchronization、Xid接口，通过与XAResource接口交互来实现分布式事务；

RM供应商（比如mysql）实现XAResource接口；

Application只需要使用TM提供的UserTransaction接口，进行事务操作即可。

```java
javax.transaction.Status：事务状态，这个接口主要是定义一些表示事务状态的常量，此接口无需实现

javax.transaction.Synchronization：同步

javax.transaction.Transaction：事务

javax.transaction.TransactionManager：事务管理器

javax.transaction.UserTransaction：用于声明一个分布式事务

javax.transaction.TransactionSynchronizationRegistry：事务同步注册

javax.transaction.xa.XAResource：定义RM提供给TM操作的接口

javax.transaction.xa.Xid：事务id
```

![image-20220512193932400](https://raw.githubusercontent.com/fwm1/PicturesRepo/master/blog-images/20220515222458.png)





### 案例

```java
package feng.test.transaction;

import com.atomikos.icatch.jta.UserTransactionImp;
import com.atomikos.jdbc.AtomikosDataSourceBean;

import javax.transaction.UserTransaction;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Properties;

public class AtomikosDemo {

    public static void main(String[] args) {
        AtomikosDataSourceBean dataSource = createAtomikosDatasource("test_db");
        AtomikosDataSourceBean dataSource1 = createAtomikosDatasource("test_db_1");
        Connection conn = null;
        Connection conn1 = null;
        PreparedStatement ps = null;
        PreparedStatement ps1 = null;
        
        UserTransaction userTransaction = new UserTransactionImp();
        try {
            //开启事务
            userTransaction.begin();

            //操作db
            conn = dataSource.getConnection();
            ps = conn.prepareStatement("INSERT into user(name) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, "fwm");
            ps.executeUpdate();

            ResultSet rs = ps.getGeneratedKeys();
            int userId = -1;
            while (rs.next()) {
                userId = rs.getInt(1);
            }

            // mock exception
            int a = 1 / 0;

            //操作db1
            conn1 = dataSource1.getConnection();
            ps1 = conn1.prepareStatement("INSERT into account(user_id,money) VALUES (?,?)");
            ps1.setInt(1, userId);
            ps1.setDouble(2, 10000000);
            ps1.executeUpdate();

            //两阶段提交
            userTransaction.commit();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            ps.close();
            ps1.close();
            conn.close();
            conn1.close();
            dataSource.close();
            dataSource1.close();
        }
    }

    private static AtomikosDataSourceBean createAtomikosDatasource(String dbName) {
        Properties p = new Properties();
        p.setProperty("url", "jdbc:mysql://localhost:3306/" + dbName);
        p.setProperty("user", "root");

        AtomikosDataSourceBean dataSourceBean = new AtomikosDataSourceBean();
        dataSourceBean.setUniqueResourceName(dbName);
        dataSourceBean.setXaDataSourceClassName("com.mysql.jdbc.jdbc2.optional.MysqlXADataSource");
        dataSourceBean.setXaProperties(p);
        return dataSourceBean;
    }
}

```

### 柔性事务

#### 1.最大努力通知

最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知等。最大努力通知型的实现方案，一般符合以下特点：

- 不可靠消息：业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。
- 定期校对：业务活动的被动方，根据定时策略，向业务活动主动方查询(主动方提供查询接口)，恢复丢失的业务消息。

#### 2.TCC两阶段补偿

TCC的作用主要是解决**跨服务调用场景下的分布式事务**问题。

- Try 完成业务检查，预留业务资源
- Confirm 使用预留的资源执行业务操作
- Cancel 取消预留的业务资源

##### TCC 与 两阶段提交

1) 在阶段1

​     XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；

​     TCC中，是主业务活动请求(try)各个从业务服务预留资源。

2) 在阶段2

​    XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支；

   TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。

TCC两阶段提交与XA两阶段提交的区别是：

**XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。** XA事务中的两阶段提交内部过程是对开发者屏蔽的，一般由TM、RM的供应商实现二阶段提交的逻辑，开发者从代码层面是感知不到这个过程。事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。

**TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。**TCC的每个阶段都需要业务代码参与，同时每个阶段都是由独立的本地事务执行，因此不会对资源一直加锁。Confirm/Cancel相当于补偿性事务（通过一个独立的事务确定/回滚上一个独立事务Try的结果）

##### TCC的优缺点

优点：XA两阶段提交资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现。有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能问题。

缺点：主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。原来只需要提供一个接口，现在需要改造成try、confirm、canel3个接口，开发成本高。



#### 3.可靠消息最终一致性

消息发送一致性：产生消息的业务操作和消息发送必须一致。如果业务操作成功，那么由这个业务操作所产生的消息一定要成功投递出去，否则由消息中间件主动丢掉消息，不进行投递。

案例分析：

```java
//1.先操作db，再发送消息; 这种情况无法保证一致性，不在一个事务里
public void buy() {
	db.buy();
	mq.send();
}
//2.先发送消息，再操作db；同样无法保证一致性
public void buy() {
	mq.send();
	db.buy();
}
//3.先发送消息，再操作db，且在一个事务里；无法保证一致性，如果db异常，mq消息无法回滚
@Transactional
public void buy() {
	mq.send();
	db.buy();
}
//4.先操作db，再发送消息，且在一个事务里；看似没有问题，mq异常会回滚db
//但是发送mq消息可能事实上已经成功，如果是响应超时导致的异常。这个时候，数据库操作依然回滚，但是MQ消息实际上已经发送成功，导致不一致
@Transactional
public void buy() {
	db.buy();
	mq.send();
}
```

##### JTA事务管理器

Spring还提供了另外一个分布式事务管理器`JtaTransactionManager`。这个是使用XA两阶段提交来保证事务的一致性。当然前提是，你的消息中间件是实现了JMS规范中事务消息相关API。

但不建议这么做，消息中间件本来就是为了异步解耦，如今把他糅合进事务里，大大降低了性能。

那么如何保证，数据库操作和消息发送的一致性呢？

##### MQ事务消息

![BE2326B0-FC19-4620-BD2E-D34A32B8A405.png](https://raw.githubusercontent.com/fwm1/PicturesRepo/master/blog-images/20220515222508.png)

![事务消息](https://raw.githubusercontent.com/fwm1/PicturesRepo/master/blog-images/20220515222512.png)

1. 发送一个事务消息，这个时候，RocketMQ将消息状态标记为Prepared，此时这条消息还没有真正投递，消费者是无法消费到
2. 执行业务代码逻辑，可能是一个本地数据库事务操作
3. 确认发送消息，这个时候，RocketMQ将消息状态标记为可消费，这个时候消费者，才能真正的保证消费到这条数据

- 如果确认消息发送失败了怎么办？

  RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。

-  如果消费失败怎么办？

  人工补偿解决

##### 本地事务表

如果MQ不支持事务消息，可以用本地事务表实现类似的功能。

1. Producer开始执行业务，向本地事务表里插入一条prepared消息记录，
2. Producer执行db事务，成功的话发送mq消息，否则删除本地事务表里的记录，
3. 监听mq发送回调，如果回调成功，将prepared状态更新为committed状态
4. 同时启动一个定时任务，扫描prepared消息记录，根据业务规则进行mq补偿或直接删除。



### 参考

http://www.tianshouzhi.com/api/tutorials/distributed_transaction/389

https://help.aliyun.com/document_detail/43348.html

https://cloud.tencent.com/developer/article/1536348



