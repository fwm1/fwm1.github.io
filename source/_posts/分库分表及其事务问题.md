---
title: 分库分表及其事务问题
date: 2022-04-16 19:45:40
tags: [分库分表]
categories: Java
---



## 为什么要分库分表

分库：单库数据量太大，达到了mysql或机器的磁盘空间、IO瓶颈

分表：单表数据量太大，即使有索引还是查询慢，且数据量一直增加。表中存在过大字段（MEDIUMTEXT、LONGTEXT等）



## 如何分库分表

### 垂直切分

垂直分库：根据业务边界划分，把不同业务表放到不同的库中

垂直分表：1）根据使用频率拆分字段；2）根据字段大小拆分字段，能减少磁盘IO

优点：

* 降低业务耦合度
* 数据库物理资源分开，方便后续业务扩展

缺点：

* 如果要看完整行数据，可能需要join多张表
* 保存数据多个表，涉及到分布式事务

### 水平切分

水平分库：单表数据量过大，将数据按照一定规则，放到不同表中。

水平分表策略：

- 按照自增id范围分表
- 按照时间区间分表
- 哈希取模分表，根据userid切分，需要考虑扩容时数据迁移的复杂性，考虑一致性hash

## 全局主键问题

- UUID
- 一个额外的自增ID表
- 雪花算法

## 事务一致性问题

分库之后，对数据的修改可能涉及多个库，此时只靠db的事务是没法保证数据一致性的，需要引入分布式事务解决方案，比如XA协议、2PC、3PC协议进行事务的提交。

分布式事务虽然能保证跨库更新的原子性，但同时也带来了延迟，提高死锁的几率。所以，如果不要求强一致性，可以考虑采用事务（日志）补偿的方式达到最终一致性。

### 典型的分布式事务解决方案

#### 两阶段提交（2PC）

2PC即为两阶段提交，是一种在多节点间实现事务原子提交的算法，用来确保所有节点要么全部提交，要么全部中止。我们可以有多种方案来实现该算法，如基于XA协议的实现，阿里也提供了Seata中间件支持2PC算法。

**准备阶段：** 协调者会在准备阶段给所有参与者都发送准备命令。如果参与者发现准备命令无法执行或者执行失败时，可以返回失败，如果执行完成则保存事务日志并返回成功。针对于数据库的操作，准备阶段会记录redolog以及undolog为后续的提交做准备。需要注意的是**在准备阶段时，数据实际是没有被真正保存的**。

**提交阶段：** 协调者在提交阶段会根据准备阶段各个参与者的返回结果，判断是执行事务还是回滚事务并向所有参与者发起提交命令。

优点：

- 事务强一致性
- 实现相对简单

缺点：

- 同步阻塞问题，其中一个节点相应慢或者超时，其他节点都得等它
- 增大死锁几率，事务从准备阶段到完成一直锁定资源
- 事务协调者单点故障风险

#### TCC

TCC分别指的是三个步骤，Try - Confirm - Cancel。与2PC类似，它在逻辑也会分成准备和提交两个阶段。但是最大的不同在于**TCC需要业务服务自己去实现准备、执行、回滚的代码，因此可以做到非常灵活。**

Try——对资源进行锁定； Confirm——执行事务；Cancel——回滚事务，取消锁定

其实TCC本质还是2PC，只是2PC针对于db操作，而TCC可以让业务实现每个阶段的操作，更加灵活。

优点：实现灵活，

缺点：代码耦合度搞，改造难度大；包含2PC的所有缺点

参考：https://github.com/dromara/hmily

#### 最大努力通知（本地消息表）

本地消息表其实就是使用了一张额外的表保存了事务操作的日志，通过定时检查日志表中的失败日志并重试，以此达到最终一致性。

优点：

- 不会长时间锁住资源，减少死锁风险
- 避免长事务，提高吞吐量

缺点：不能保证强一致性

## 总结

**2PC** 是强一致性的事务，适合用在数据库层面。

**TCC** 也是强一致性的事务，适合大部分场景，但是对业务代码有侵入，开发量也很大。

**最大努力通知** 是最终一致性事务。



参考链接：

https://zhuanlan.zhihu.com/p/264847518

https://github.com/dromara/hmily

https://www.diaosi.love/archives/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1#toc-head-15

