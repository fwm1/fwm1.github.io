---
title: 动态线程池实现思路
date: 2022-04-19 22:01:48
tags: 
categorie: 多线程
---

## jdk线程池分析

#### 如何执行任务

```java
ThreadPoolExecutor#execute
    
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    //线程池利用AtomicInteger 一个ctl变量来同时保存当前池状态（高3位）和当前池线程数（低29位）
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            //1.如果当前线程数 < 核心线程池，则新建一个线程来处理提交的任务
            return;
        c = ctl.get();
    }
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            //2.线程池处于非running状态，从任务队列移除任务并执行拒绝策略
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    //3.如果当前线程数 > 核心线程数且任务队列没满，则将任务放入任务队列等待执行
    else if (!addWorker(command, false))
        //4.如果当前线程数 > 最大线程数，且队列已满，则拒绝该任务
        reject(command);
}
```



#### Woker线程管理

Worker是线程池内的工作线程

1. 继承了AQS（执行时通过锁住worker对象表示任务正在执行中，并且是不可重入的）
2. 实现了Runnable接口，在run方法里循环从任务队列获取任务

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;//Worker持有的线程
    Runnable firstTask;//初始化的任务，可以为null。为null表示非核心线程
    
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
}
```

![03268b9dc49bd30bb63064421bb036bf90315](https://s2.loli.net/2022/04/21/uPRDxwmzYApgtif.png)

##### 非核心线程如何回收

线程池中线程的销毁依赖JVM自动的回收，ThreadPoolExecutor**通过一个hashset持有线程的引用**，防止这些线程被回收。对于需要回收的线程，只要移除引用即可。

在addWorker方法中，如果Worker创建成功，会将worker的引用添加到workers一个hashset里面，非核心线程在拉取任务超时后，会执行processWorkerExit，将自己的引用从workers里面移除，之后就交给gc去回收线程。

##### 如何判断worker线程的状态

Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。

1. lock方法一旦获取了独占锁，表示当前线程正在执行任务中。如果正在执行任务，则不应该中断线程
2. 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会**使用tryLock方法来判断线程池中的线程是否是空闲状态**；如果线程是空闲状态则可以安全回收。

![图8 线程池回收过程](https://p1.meituan.net/travelcube/9d8dc9cebe59122127460f81a98894bb34085.png)
